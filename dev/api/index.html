<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SimulationAnalysis.jl</title><meta name="title" content="API · SimulationAnalysis.jl"/><meta property="og:title" content="API · SimulationAnalysis.jl"/><meta property="twitter:title" content="API · SimulationAnalysis.jl"/><meta name="description" content="Documentation for SimulationAnalysis.jl."/><meta property="og:description" content="Documentation for SimulationAnalysis.jl."/><meta property="twitter:description" content="Documentation for SimulationAnalysis.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SimulationAnalysis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Simulation"><span>Simulation</span></a></li><li><a class="tocitem" href="#K-Space"><span>K-Space</span></a></li><li><a class="tocitem" href="#Correlation-Function"><span>Correlation Function</span></a></li><li><a class="tocitem" href="#Density-Modes"><span>Density Modes</span></a></li><li><a class="tocitem" href="#Forces"><span>Forces</span></a></li><li><a class="tocitem" href="#Intermediate-Scattering-Function"><span>Intermediate Scattering Function</span></a></li><li><a class="tocitem" href="#Structure-Factors"><span>Structure Factors</span></a></li><li><a class="tocitem" href="#Mean-Squared-Displacement"><span>Mean Squared Displacement</span></a></li><li><a class="tocitem" href="#Overlap-Function"><span>Overlap Function</span></a></li><li><a class="tocitem" href="#Neighborlists"><span>Neighborlists</span></a></li><li><a class="tocitem" href="#Bond-Breaking-Parameter"><span>Bond Breaking Parameter</span></a></li><li><a class="tocitem" href="#Utils"><span>Utils</span></a></li><li><a class="tocitem" href="#Radial-Distribution-Function"><span>Radial Distribution Function</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Simulation"><a class="docs-heading-anchor" href="#Simulation">Simulation</a><a id="Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.SingleComponentSimulation" href="#SimulationAnalysis.SingleComponentSimulation"><code>SimulationAnalysis.SingleComponentSimulation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SingleComponentSimulation</code></pre><p>A mutable struct that holds all data for a single-component particle simulation.</p><p><strong>Fields</strong></p><ul><li><code>N::Int64</code>: Number of particles.</li><li><code>Ndims::Int64</code>: Number of spatial dimensions.</li><li><code>Nt::Int64</code>: Number of time steps.</li><li><code>dt::Float64</code>: Time step size.</li><li><code>r_array::Array{Float64, 3}</code>: Particle positions. The dimensions of the array are <code>(N, Ndims, N_time_steps)</code>.</li><li><code>v_array::Array{Float64, 3}</code>: Particle velocities. The dimensions of the array are <code>(N, Ndims, N_time_steps)</code>.</li><li><code>F_array::Array{Float64, 3}</code>: Forces on particles. The dimensions of the array are <code>(N, Ndims, N_time_steps)</code>.</li><li><code>D_array::Array{Float64, 1}</code>: Diameter for each particle.</li><li><code>t_array::Array{Float64, 1}</code>: Vector of time points corresponding to each time step.</li><li><code>box_sizes::Vector{Float64}</code>: A vector holding the simulation box dimensions, e.g., <code>[Lx, Ly, Lz]</code>.</li><li><code>dt_array::Array{Float64, 1}</code>: An array of time step differences (<code>Δt</code>) used for calculating time correlation functions.</li><li><code>t1_t2_pair_array::Vector{Array{Int64, 2}}</code>: An array of <code>(t1, t2)</code> index pairs, used for efficient calculation of time correlations.</li><li><code>filepath::String</code>: Path to the file from which the simulation data was loaded.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Simulation.jl#L2-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.MultiComponentSimulation" href="#SimulationAnalysis.MultiComponentSimulation"><code>SimulationAnalysis.MultiComponentSimulation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultiComponentSimulation</code></pre><p>A mutable struct that holds all data for a multi-component particle simulation.</p><p><strong>Fields</strong></p><ul><li><code>N::Int64</code>: Total number of particles across all species.</li><li><code>Ndims::Int64</code>: Number of spatial dimensions.</li><li><code>N_species::Int64</code>: Number of different particle species.</li><li><code>Nt::Int64</code>: Number of time steps.</li><li><code>dt::Float64</code>: Time step size.</li><li><code>N_particles_per_species::Vector{Int}</code>: A vector containing the number of particles for each species.</li><li><code>r_array::Vector{Array{Float64, 3}}</code>: A vector of particle position arrays. Each element <code>r_array[i]</code> is a <code>(N_particles_per_species[i], Ndims, N_time_steps)</code> array for species <code>i</code>.</li><li><code>v_array::Vector{Array{Float64, 3}}</code>: A vector of particle velocity arrays for each species.</li><li><code>F_array::Vector{Array{Float64, 3}}</code>: A vector of particle force arrays for each species.</li><li><code>t_array::Vector{Float64}</code>: Vector of time points corresponding to each time step.</li><li><code>box_sizes::Vector{Float64}</code>: A vector holding the simulation box dimensions, e.g., <code>[Lx, Ly, Lz]</code>.</li><li><code>dt_array::Vector{Float64}</code>: An array of time step differences (<code>Δt</code>) used for calculating time correlation functions.</li><li><code>t1_t2_pair_array::Vector{Array{Int64, 2}}</code>: An array of <code>(t1, t2)</code> index pairs, used for efficient calculation of time correlations.</li><li><code>filepath::String</code>: Path to the file from which the simulation data was loaded.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Simulation.jl#L38-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.SelfPropelledVoronoiSimulation" href="#SimulationAnalysis.SelfPropelledVoronoiSimulation"><code>SimulationAnalysis.SelfPropelledVoronoiSimulation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SelfPropelledVoronoiSimulation</code></pre><p>A mutable struct that holds all data for a self-propelled Voronoi particle simulation.</p><p><strong>Fields</strong></p><ul><li><code>N::Int64</code>: Number of particles.</li><li><code>Ndims::Int64</code>: Number of spatial dimensions.</li><li><code>Nt::Int64</code>: Number of time steps.</li><li><code>dt::Float64</code>: Time step size.</li><li><code>r_array::Array{Float64, 3}</code>: Particle positions.</li><li><code>u_array::Array{Float64, 2}</code>: Particle orientations (radians).</li><li><code>F_array::Array{Float64, 3}</code>: Forces on particles.</li><li><code>perimeter_array::Array{Float64, 2}</code>: Perimeters of Voronoi cells.</li><li><code>area_array::Array{Float64, 2}</code>: Areas of Voronoi cells.</li><li><code>Epot_array::Array{Float64, 1}</code>: Potential energies.</li><li><code>t_array::Vector{Float64}</code>: Vector of time points.</li><li><code>box_sizes::Vector{Float64}</code>: Dimensions of the simulation box.</li><li><code>dt_array::Vector{Float64}</code>: Time step sizes.</li><li><code>t1_t2_pair_array::Vector{Array{Int64, 2}}</code>: Array of <code>(t1, t2)</code> index pairs.</li><li><code>filepath::String</code>: Path to the file from which the simulation data was loaded.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Simulation.jl#L76-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.MCSPVSimulation" href="#SimulationAnalysis.MCSPVSimulation"><code>SimulationAnalysis.MCSPVSimulation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MCSPVSimulation</code></pre><p>A mutable struct that holds all data for a multi-component self-propelled Voronoi particle simulation.</p><p><strong>Fields</strong></p><ul><li><code>N::Int64</code>: Number of particles.</li><li><code>Ndims::Int64</code>: Number of spatial dimensions.</li><li><code>N_species::Int64</code>: Number of different particle species.</li><li><code>Nt::Int64</code>: Number of time steps.</li><li><code>dt::Float64</code>: Time step size.</li><li><code>N_particles_per_species::Vector{Int}</code>: A vector containing the number of particles for each species.</li><li><code>r_array::Vector{Array{Float64, 3}}</code>: A vector of particle position arrays. Each element <code>r_array[i]</code> is a <code>(N_particles_per_species[i], Ndims, N_time_steps)</code> array for species <code>i</code>.</li><li><code>u_array::Vector{Array{Float64, 2}}</code>: A vector of particle orientation arrays for each species.</li><li><code>F_array::Vector{Array{Float64, 3}}</code>: A vector of particle force arrays for each species.</li><li><code>perimeter_array::Vector{Array{Float64, 2}}</code>: A vector of Voronoi cell perimeter arrays for each species.</li><li><code>area_array::Vector{Array{Float64, 2}}</code>: A vector of Voronoi cell area arrays for each species.</li><li><code>Epot_array::Vector{Array{Float64, 1}}</code>: A vector of potential energy arrays for each species.</li><li><code>t_array::Vector{Float64}</code>: Vector of time points corresponding to each time step.</li><li><code>box_sizes::Vector{Float64}</code>: A vector holding the simulation box dimensions, e.g., <code>[Lx, Ly, Lz]</code>.</li><li><code>dt_array::Vector{Float64}</code>: An array of time step differences (<code>Δt</code>) used for calculating time correlation functions.</li><li><code>t1_t2_pair_array::Vector{Array{Int64, 2}}</code>: An array of <code>(t1, t2)</code> index pairs, used for efficient calculation of time correlations.</li><li><code>filepath::String</code>: Path to the file from which the simulation data was loaded.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Simulation.jl#L116-L139">source</a></section></article><h2 id="K-Space"><a class="docs-heading-anchor" href="#K-Space">K-Space</a><a id="K-Space-1"></a><a class="docs-heading-anchor-permalink" href="#K-Space" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.KSpace" href="#SimulationAnalysis.KSpace"><code>SimulationAnalysis.KSpace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KSpace{dims, S, OA}</code></pre><p>A struct to hold the reciprocal space (k-space) vectors for a simulation.</p><p>This struct is usually created via <a href="#SimulationAnalysis.construct_k_space"><code>construct_k_space</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>s::S</code>: The <code>Simulation</code> object for which the k-space is defined.</li><li><code>Nk::Int64</code>: The total number of k-vectors.</li><li><code>k_lengths::Vector{Float64}</code>: A vector of length <code>Nk</code> containing the magnitude of each k-vector.</li><li><code>k_array::Matrix{Float64}</code>: A <code>(dims, Nk)</code> matrix where each column is a k-vector <code>(kx, ky, kz, ...)</code>.</li><li><code>kfactor::Int64</code>: An integer scaling factor used to determine the resolution of the k-space grid. A higher factor means a courser grid.</li><li><code>cartesian_to_linear::OA</code>: An <code>OffsetArray</code> that maps the Cartesian grid indices <code>(ix, iy, iz, ...)</code> of a k-vector to its linear index in <code>k_lengths</code> and <code>k_array</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Kspace.jl#L2-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.construct_k_space" href="#SimulationAnalysis.construct_k_space"><code>SimulationAnalysis.construct_k_space</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">construct_k_space(s::Simulation, bounds; kfactor=1, negative=false, rectangular=false)</code></pre><p>Constructs the k-space for a given simulation.</p><p>This function generates a set of k-vectors based on the simulation box and specified parameters. The k-vectors are chosen from a grid with spacing <code>2π/L * kfactor</code>, where <code>L</code> is the box size in each dimension.</p><p><strong>Arguments</strong></p><ul><li><code>s::Simulation</code>: The simulation object (<code>SingleComponentSimulation</code> or <code>MultiComponentSimulation</code>).</li><li><code>bounds</code>: A tuple or vector <code>(kmin, kmax)</code> specifying the range of magnitudes for the k-vectors. k-vectors with magnitude <code>k</code> such that <code>kmin &lt; k &lt; kmax</code> are included.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kfactor::Int=1</code>: An integer scaling factor for the k-vector grid resolution.</li><li><code>negative::Bool=false</code>: If <code>true</code>, includes k-vectors with negative components for the first <code>d-1</code> dimensions.</li><li><code>rectangular::Bool=false</code>: If <code>true</code>, a rectangular k-space grid is generated, and all k-vectors within the grid up to <code>kmax</code> are included, ignoring <code>kmin</code>. If <code>false</code>, k-vectors are selected from a spherical shell.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>KSpace</code> object containing the generated k-vectors and related information.</li></ul><p>See also: <a href="#SimulationAnalysis.KSpace"><code>KSpace</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Kspace.jl#L26-L47">source</a></section></article><h2 id="Correlation-Function"><a class="docs-heading-anchor" href="#Correlation-Function">Correlation Function</a><a id="Correlation-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Correlation-Function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.find_correlation_function" href="#SimulationAnalysis.find_correlation_function"><code>SimulationAnalysis.find_correlation_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_correlation_function(A, B, s)</code></pre><p>Computes the correlation function between two lists of observables. The observables are assumed to be complex-valued. The correlation function is a complex number. The correlation function is averaged over the first dimension of A and B.</p><p><strong>Arguments</strong></p><ul><li><code>A::Array{Complex{Float64}, 2}</code>: The first list of observables.</li><li><code>B::Array{Complex{Float64}, 2}</code>: The second list of observables.</li><li><code>s::Simulation</code>: The simulation.</li></ul><p><strong>Returns</strong></p><ul><li><code>C::Array{Complex{Float64}, 1}</code>: The correlation function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/CorrelationFunction.jl#L93-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.find_correlation_matrix" href="#SimulationAnalysis.find_correlation_matrix"><code>SimulationAnalysis.find_correlation_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_correlation_matrix(observables_list1, observables_list2, kspace, s)</code></pre><p>Computes the correlation matrix between two lists of observables. The observables are assumed to be complex-valued. The correlation matrix is a matrix of complex numbers.</p><p><strong>Arguments</strong></p><ul><li><code>observables_list1::Array{Array{Complex{Float64}, 2}, 1}</code>: The first list of observables.</li><li><code>observables_list2::Array{Array{Complex{Float64}, 2}, 1}</code>: The second list of observables.</li><li><code>s::Simulation</code>: The simulation.</li></ul><p><strong>Returns</strong></p><ul><li><code>matrix::Array{Array{Complex{Float64}, 1}, 2}</code>: The correlation matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/CorrelationFunction.jl#L118-L131">source</a></section></article><h2 id="Density-Modes"><a class="docs-heading-anchor" href="#Density-Modes">Density Modes</a><a id="Density-Modes-1"></a><a class="docs-heading-anchor-permalink" href="#Density-Modes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.find_density_modes" href="#SimulationAnalysis.find_density_modes"><code>SimulationAnalysis.find_density_modes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_density_modes(s::SingleComponentSimulation, kspace::KSpace; verbose=true)</code></pre><p>Calculates the density modes <code>ρ(k,t) = Σ_j exp(i * k ⋅ r_j(t))</code> for a single-component simulation.</p><p>The calculation is performed for all k-vectors in <code>kspace</code> and for all time steps in the simulation. This function is computationally intensive. The <code>verbose</code> option can be used to monitor progress.</p><p><strong>Arguments</strong></p><ul><li><code>s::SingleComponentSimulation</code>: The simulation data.</li><li><code>kspace::KSpace</code>: The k-space vectors for which to calculate the density modes.</li><li><code>verbose::Bool=true</code>: If <code>true</code>, prints progress and performance information to the console.</li></ul><p><strong>Returns</strong></p><ul><li><code>SingleComponentDensityModes</code>: A struct containing the real and imaginary parts of the density modes.</li></ul><p>See also: <a href="#SimulationAnalysis.SingleComponentDensityModes"><code>SingleComponentDensityModes</code></a>, <a href="#SimulationAnalysis.find_density_modes"><code>find_density_modes(::Union{MultiComponentSimulation,MCSPVSimulation}, ::KSpace)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/DensityModes.jl#L49-L66">source</a></section><section><div><pre><code class="language-julia hljs">find_density_modes(s::Union{MultiComponentSimulation,MCSPVSimulation}, kspace::KSpace; verbose=true)</code></pre><p>Calculates the density modes <code>ρ_s(k,t) = Σ_j exp(i * k ⋅ r_j(t))</code> for each species <code>s</code> in a multi-component simulation.</p><p>The calculation is performed for all k-vectors in <code>kspace</code> and for all time steps in the simulation. This function is computationally intensive. The <code>verbose</code> option can be used to monitor progress.</p><p><strong>Arguments</strong></p><ul><li><code>s::Union{MultiComponentSimulation,MCSPVSimulation}</code>: The simulation data.</li><li><code>kspace::KSpace</code>: The k-space vectors for which to calculate the density modes.</li><li><code>verbose::Bool=true</code>: If <code>true</code>, prints progress and performance information to the console.</li></ul><p><strong>Returns</strong></p><ul><li><code>MultiComponentDensityModes</code>: A struct containing the real and imaginary parts of the density modes for each species.</li></ul><p>See also: <a href="#SimulationAnalysis.MultiComponentDensityModes"><code>MultiComponentDensityModes</code></a>, <a href="#SimulationAnalysis.find_density_modes"><code>find_density_modes(::SingleComponentSimulation, ::KSpace)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/DensityModes.jl#L87-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.SingleComponentDensityModes" href="#SimulationAnalysis.SingleComponentDensityModes"><code>SimulationAnalysis.SingleComponentDensityModes</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SingleComponentDensityModes</code></pre><p>A struct to hold the density modes <code>ρ(k,t)</code> for a single-component simulation.</p><p>The density modes are defined as <code>ρ(k,t) = Σ_j exp(i * k ⋅ r_j(t))</code>, where the sum is over all particles <code>j</code>. This struct stores the real and imaginary parts of <code>ρ(k,t)</code> for various k-vectors and time steps.</p><p><strong>Fields</strong></p><ul><li><code>Re::Matrix{Float64}</code>: The real part of the density modes, <code>Σ_j cos(k ⋅ rj)</code>. Dimensions are <code>(N_timesteps, Nk)</code>.</li><li><code>Im::Matrix{Float64}</code>: The imaginary part of the density modes, <code>Σ_j sin(k ⋅ rj)</code>. Dimensions are <code>(N_timesteps, Nk)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/DensityModes.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.MultiComponentDensityModes" href="#SimulationAnalysis.MultiComponentDensityModes"><code>SimulationAnalysis.MultiComponentDensityModes</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultiComponentDensityModes</code></pre><p>A struct to hold the density modes <code>ρ_s(k,t)</code> for each species <code>s</code> in a multi-component simulation.</p><p>The density modes for each species are defined as <code>ρ_s(k,t) = Σ_j exp(i * k ⋅ r_j(t))</code>, where the sum is over all particles <code>j</code> of species <code>s</code>. This struct stores the real and imaginary parts of <code>ρ_s(k,t)</code> for various k-vectors and time steps.</p><p><strong>Fields</strong></p><ul><li><code>Re::Vector{Matrix{Float64}}</code>: A vector where <code>Re[s]</code> is the real part of the density modes for species <code>s</code>. Each matrix has dimensions <code>(N_timesteps, Nk)</code>.</li><li><code>Im::Vector{Matrix{Float64}}</code>: A vector where <code>Im[s]</code> is the imaginary part of the density modes for species <code>s</code>. Each matrix has dimensions <code>(N_timesteps, Nk)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/DensityModes.jl#L25-L36">source</a></section></article><h2 id="Forces"><a class="docs-heading-anchor" href="#Forces">Forces</a><a id="Forces-1"></a><a class="docs-heading-anchor-permalink" href="#Forces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.Weysser" href="#SimulationAnalysis.Weysser"><code>SimulationAnalysis.Weysser</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Weysser &lt;: InteractionPotential</code></pre><p>A struct for the Weysser interaction potential.</p><p><strong>Fields</strong></p><ul><li><code>ϵ::Float64</code>: The interaction strength.</li><li><code>δ::Float64</code>: The interaction range.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Forces.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.Berthier" href="#SimulationAnalysis.Berthier"><code>SimulationAnalysis.Berthier</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Berthier &lt;: InteractionPotential</code></pre><p>A struct for the Berthier interaction potential.</p><p><strong>Fields</strong></p><ul><li><code>c0::Float64</code>: The c0 coefficient.</li><li><code>c2::Float64</code>: The c2 coefficient.</li><li><code>c4::Float64</code>: The c4 coefficient.</li><li><code>ζ::Float64</code>: The zeta coefficient.</li><li><code>σ_ratio::Float64</code>: The ratio of the diameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Forces.jl#L17-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.WCA" href="#SimulationAnalysis.WCA"><code>SimulationAnalysis.WCA</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WCA &lt;: InteractionPotential</code></pre><p>A struct for the WCA interaction potential.</p><p><strong>Fields</strong></p><ul><li><code>ϵ::Float64</code>: The interaction strength.</li><li><code>σ::Float64</code>: The interaction range.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Forces.jl#L37-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.KAWCA" href="#SimulationAnalysis.KAWCA"><code>SimulationAnalysis.KAWCA</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KAWCA &lt;: InteractionPotential</code></pre><p>A struct for the Kob-Andersen WCA interaction potential.</p><p><strong>Fields</strong></p><ul><li><code>ϵ11::Float64</code>: The interaction strength between particles of type 1.</li><li><code>ϵ12::Float64</code>: The interaction strength between particles of type 1 and 2.</li><li><code>ϵ22::Float64</code>: The interaction strength between particles of type 2.</li><li><code>σ11::Float64</code>: The interaction range between particles of type 1.</li><li><code>σ12::Float64</code>: The interaction range between particles of type 1 and 2.</li><li><code>σ22::Float64</code>: The interaction range between particles of type 2.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Forces.jl#L51-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.calculate_forces!" href="#SimulationAnalysis.calculate_forces!"><code>SimulationAnalysis.calculate_forces!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_forces!(s, forcestype::Bool)</code></pre><p>Calculate the forces for a simulation.</p><p>This is a placeholder function that throws an error if <code>forcestype</code> is true.</p><p><strong>Arguments</strong></p><ul><li><code>s</code>: The simulation object.</li><li><code>forcestype::Bool</code>: Whether to calculate forces.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/LoadData.jl#L1058-L1068">source</a></section><section><div><pre><code class="language-julia hljs">calculate_forces!(s, U; friction=false, cutoff=1.25)</code></pre><p>Recalculates the total force on all particles according to the langevin equation F = -∇U - γv. This function also updates the total potential energy in the output datastructure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Forces.jl#L154-L159">source</a></section><section><div><pre><code class="language-julia hljs">calculate_forces!(s, U::KAWCA; cutoff=2.0^(1.0/6.0))</code></pre><p>Recalculates the total force on all particles in a multi-component simulation <code>s</code> according to the Kob-Andersen Weeks-Chandler-Andersen system U, and updates the force array in <code>s</code> with the calculated values.</p><p><strong>Arguments</strong></p><ul><li><code>s</code>: a <code>MultiComponentSimulation</code> object that contains the position and force arrays for each particle.</li><li><code>U::KAWCA</code>: the interaction type.</li><li><code>cutoff</code>: the cutoff distance for the potential energy function. Default is <code>2.0^(1.0/6.0)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Forces.jl#L258-L267">source</a></section></article><h2 id="Intermediate-Scattering-Function"><a class="docs-heading-anchor" href="#Intermediate-Scattering-Function">Intermediate Scattering Function</a><a id="Intermediate-Scattering-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Intermediate-Scattering-Function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.find_intermediate_scattering_function" href="#SimulationAnalysis.find_intermediate_scattering_function"><code>SimulationAnalysis.find_intermediate_scattering_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_intermediate_scattering_function(s::Simulation; kmin=7.0, kmax=7.4, kfactor=1)</code></pre><p>Calculates the coherent intermediate scattering function <code>F(k, t)</code> for a simulation, averaged over a shell in k-space.</p><p>This is a convenience function that first constructs the k-space and density modes, and then computes <code>F(k, t)</code>. The function is defined as: <code>F(k, t) = (1/N) * &lt; Σ_{i,j} exp(i * k ⋅ (r_i(t) - r_j(0))) &gt;</code>. The average is taken over time origins and over k-vectors with magnitudes <code>k</code> such that <code>kmin &lt; k &lt; kmax</code>.</p><p><strong>Arguments</strong></p><ul><li><code>s::Simulation</code>: The simulation data.</li><li><code>kmin::Float64=7.0</code>: The minimum magnitude of the k-vectors to be included in the average.</li><li><code>kmax::Float64=7.4</code>: The maximum magnitude of the k-vectors to be included in the average.</li><li><code>kfactor::Int=1</code>: The resolution factor for the k-space grid.</li></ul><p><strong>Returns</strong></p><ul><li><code>Fk</code>: The intermediate scattering function. For a <code>SingleComponentSimulation</code>, this is a <code>Vector{Float64}</code>. For a <code>MultiComponentSimulation</code>, this is a <code>Matrix{Vector{Float64}}</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/IntermediateScatteringFunction.jl#L1-L18">source</a></section><section><div><pre><code class="language-julia hljs">find_intermediate_scattering_function(s::Simulation, kspace::KSpace, ρkt, k_sample_array::AbstractVector; k_binwidth=0.1)</code></pre><p>Calculates the coherent intermediate scattering function <code>F(k, t)</code> for a list of specified <code>k</code> values.</p><p>For each <code>k</code> in <code>k_sample_array</code>, this function computes <code>F(k, t)</code> by averaging over a k-shell of width <code>k_binwidth</code> centered at <code>k</code>.</p><p><strong>Arguments</strong></p><ul><li><code>s::Simulation</code>: The simulation data.</li><li><code>kspace::KSpace</code>: The pre-computed k-space.</li><li><code>ρkt</code>: The pre-computed density modes (<code>SingleComponentDensityModes</code> or <code>MultiComponentDensityModes</code>).</li><li><code>k_sample_array::AbstractVector</code>: A vector of k-magnitudes for which to compute <code>F(k, t)</code>.</li><li><code>k_binwidth::Float64=0.1</code>: The width of the k-shell to average over for each value in <code>k_sample_array</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>F_array::Vector</code>: A vector where <code>F_array[i]</code> is the <code>F(k,t)</code> corresponding to <code>k_sample_array[i]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/IntermediateScatteringFunction.jl#L26-L42">source</a></section><section><div><pre><code class="language-julia hljs">find_intermediate_scattering_function(s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}, kspace::KSpace, ρkt::SingleComponentDensityModes; kmin=0.0, kmax=10.0^10.0)</code></pre><p>Calculates the coherent intermediate scattering function <code>F(k, t)</code> for a single-component simulation.</p><p>This is the main implementation that computes <code>F(k, t) = (1/N) * &lt;ρ(k, t) ρ*(-k, 0)&gt;</code> by correlating the pre-computed density modes <code>ρkt</code>. The average is performed over time origins and k-vectors within the magnitude range <code>[kmin, kmax]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}</code>: The simulation data.</li><li><code>kspace::KSpace</code>: The pre-computed k-space.</li><li><code>ρkt::SingleComponentDensityModes</code>: The pre-computed density modes.</li><li><code>kmin::Float64=0.0</code>: The minimum magnitude of k-vectors to include in the average.</li><li><code>kmax::Float64=10.0^10.0</code>: The maximum magnitude of k-vectors to include in the average.</li></ul><p><strong>Returns</strong></p><ul><li><code>Fk::Vector{Float64}</code>: A vector containing <code>F(k, t)</code> for each time delay <code>Δt</code> in <code>s.dt_array</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/IntermediateScatteringFunction.jl#L53-L70">source</a></section><section><div><pre><code class="language-julia hljs">find_intermediate_scattering_function(s::Union{MultiComponentSimulation,MCSPVSimulation}, kspace::KSpace, ρkt::MultiComponentDensityModes; kmin=0.0, kmax=10.0^10.0)</code></pre><p>Calculates the partial intermediate scattering functions <code>F_αβ(k, t)</code> for a multi-component simulation.</p><p>This function computes <code>F_αβ(k, t) = (1/N) * &lt;ρ_α(k, t) ρ_β*(-k, 0)&gt;</code> by correlating the pre-computed density modes <code>ρkt</code> for species <code>α</code> and <code>β</code>. The average is performed over time origins and k-vectors within the magnitude range <code>[kmin, kmax]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>s::Union{MultiComponentSimulation,MCSPVSimulation}</code>: The simulation data.</li><li><code>kspace::KSpace</code>: The pre-computed k-space.</li><li><code>ρkt::MultiComponentDensityModes</code>: The pre-computed density modes for all species.</li><li><code>kmin::Float64=0.0</code>: The minimum magnitude of k-vectors to include in the average.</li><li><code>kmax::Float64=10.0^10.0</code>: The maximum magnitude of k-vectors to include in the average.</li></ul><p><strong>Returns</strong></p><ul><li><code>Fk::Matrix{Vector{Float64}}</code>: A matrix of vectors, where <code>Fk[α, β]</code> is the partial intermediate scattering function <code>F_αβ(k, t)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/IntermediateScatteringFunction.jl#L78-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.find_self_intermediate_scattering_function" href="#SimulationAnalysis.find_self_intermediate_scattering_function"><code>SimulationAnalysis.find_self_intermediate_scattering_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_self_intermediate_scattering_function(s::Simulation; kmin=7.0, kmax=7.4, kfactor=1)</code></pre><p>Calculates the self-intermediate scattering function <code>Fs(k, t)</code>, averaged over a shell in k-space.</p><p>This is a convenience function that first constructs the k-space and then computes <code>Fs(k, t)</code>. The function is defined as: <code>Fs(k, t) = (1/N) * &lt;Σ_j exp(i * k ⋅ (r_j(t) - r_j(0)))&gt;</code>. The average is taken over time origins and over k-vectors with magnitudes <code>k</code> such that <code>kmin &lt; k &lt; kmax</code>. This function is only implemented for <code>SingleComponentSimulation</code>.</p><p><strong>Arguments</strong></p><ul><li><code>s::Simulation</code>: The simulation data.</li><li><code>kmin::Float64=7.0</code>: The minimum magnitude of the k-vectors to be included in the average.</li><li><code>kmax::Float64=7.4</code>: The maximum magnitude of the k-vectors to be included in the average.</li><li><code>kfactor::Int=1</code>: The resolution factor for the k-space grid.</li></ul><p><strong>Returns</strong></p><ul><li><code>Fk::Vector{Float64}</code>: A vector containing <code>Fs(k, t)</code> for each time delay <code>Δt</code> in <code>s.dt_array</code>.</li><li><code>Fks_per_particle::Matrix{Float64}</code>: A <code>(Ndt, N)</code> matrix containing the self-intermediate scattering function for each particle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/IntermediateScatteringFunction.jl#L109-L128">source</a></section><section><div><pre><code class="language-julia hljs">find_self_intermediate_scattering_function(s::Simulation, kspace::KSpace, k_sample_array::AbstractVector; k_binwidth=0.1)</code></pre><p>Calculates the self-intermediate scattering function <code>Fs(k, t)</code> for a list of specified <code>k</code> values.</p><p>For each <code>k</code> in <code>k_sample_array</code>, this function computes <code>Fs(k, t)</code> by averaging over a k-shell of width <code>k_binwidth</code> centered at <code>k</code>. This function is only implemented for <code>SingleComponentSimulation</code>.</p><p><strong>Arguments</strong></p><ul><li><code>s::Simulation</code>: The simulation data.</li><li><code>kspace::KSpace</code>: The pre-computed k-space.</li><li><code>k_sample_array::AbstractVector</code>: A vector of k-magnitudes for which to compute <code>Fs(k, t)</code>.</li><li><code>k_binwidth::Float64=0.1</code>: The width of the k-shell to average over for each value in <code>k_sample_array</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>F_array::Vector</code>: A vector of tuples <code>(Fk, Fks_per_particle)</code> for each <code>k</code> in <code>k_sample_array</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/IntermediateScatteringFunction.jl#L135-L151">source</a></section><section><div><pre><code class="language-julia hljs">find_self_intermediate_scattering_function(s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}, kspace::KSpace; kmin=0.0, kmax=10.0^10.0)</code></pre><p>Calculates the self-intermediate scattering function <code>Fs(k, t)</code> for a single-component simulation.</p><p>This is the main implementation that computes <code>Fs(k, t) = (1/N) * &lt;Σ_j exp(i * k ⋅ (r_j(t) - r_j(0)))&gt;</code>. The calculation is done without pre-calculating density modes to avoid large memory allocation. The average is performed over time origins and k-vectors within the magnitude range <code>[kmin, kmax]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}</code>: The simulation data.</li><li><code>kspace::KSpace</code>: The pre-computed k-space.</li><li><code>kmin::Float64=0.0</code>: The minimum magnitude of k-vectors to include in the average.</li><li><code>kmax::Float64=10.0^10.0</code>: The maximum magnitude of k-vectors to include in the average.</li></ul><p><strong>Returns</strong></p><ul><li><code>Fk::Vector{Float64}</code>: A vector containing <code>Fs(k, t)</code> for each time delay <code>Δt</code> in <code>s.dt_array</code>.</li><li><code>Fks_per_particle::Matrix{Float64}</code>: A <code>(Ndt, N)</code> matrix containing the self-intermediate scattering function for each particle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/IntermediateScatteringFunction.jl#L162-L180">source</a></section></article><h2 id="Structure-Factors"><a class="docs-heading-anchor" href="#Structure-Factors">Structure Factors</a><a id="Structure-Factors-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-Factors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.find_structure_factor" href="#SimulationAnalysis.find_structure_factor"><code>SimulationAnalysis.find_structure_factor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_structure_factor(s::Simulation; kmin=7.0, kmax=7.4, kfactor=1)</code></pre><p>Calculates the static structure factor <code>S(k)</code> for a simulation, averaged over a shell in k-space.</p><p>This is a convenience function that first constructs the k-space and density modes, and then computes <code>S(k)</code>. The function is defined as: <code>S(k) = (1/N) * &lt;|Σ_j exp(i * k ⋅ r_j)|^2&gt;</code>. The average is taken over time and over k-vectors with magnitudes <code>k</code> such that <code>kmin &lt; k &lt; kmax</code>.</p><p><strong>Arguments</strong></p><ul><li><code>s::Simulation</code>: The simulation data.</li><li><code>kmin::Float64=7.0</code>: The minimum magnitude of the k-vectors to be included in the average.</li><li><code>kmax::Float64=7.4</code>: The maximum magnitude of the k-vectors to be included in the average.</li><li><code>kfactor::Int=1</code>: The resolution factor for the k-space grid.</li></ul><p><strong>Returns</strong></p><ul><li><code>Sk</code>: The structure factor. For a <code>SingleComponentSimulation</code>, this is a <code>Float64</code>. For a <code>MultiComponentSimulation</code>, this is a <code>Matrix{Float64}</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/StructureFactors.jl#L32-L49">source</a></section><section><div><pre><code class="language-julia hljs">find_structure_factor(s::Simulation, kspace::KSpace, ρkt::AbstractDensityModes, k_sample_array::AbstractVector; k_binwidth=0.1)</code></pre><p>Calculates the static structure factor <code>S(k)</code> for a list of specified <code>k</code> values.</p><p>For each <code>k</code> in <code>k_sample_array</code>, this function computes <code>S(k)</code> by averaging over a k-shell of width <code>k_binwidth</code> centered at <code>k</code>.</p><p><strong>Arguments</strong></p><ul><li><code>s::Simulation</code>: The simulation data.</li><li><code>kspace::KSpace</code>: The pre-computed k-space.</li><li><code>ρkt::AbstractDensityModes</code>: The pre-computed density modes.</li><li><code>k_sample_array::AbstractVector</code>: A vector of k-magnitudes for which to compute <code>S(k)</code>.</li><li><code>k_binwidth::Float64=0.1</code>: The width of the k-shell to average over for each value in <code>k_sample_array</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>S_array::Vector</code>: A vector where <code>S_array[i]</code> is the <code>S(k)</code> corresponding to <code>k_sample_array[i]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/StructureFactors.jl#L57-L73">source</a></section><section><div><pre><code class="language-julia hljs">find_structure_factor(s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}, kspace::KSpace, ρkt::SingleComponentDensityModes; kmin=0.0, kmax=10.0^10.0)</code></pre><p>Calculates the static structure factor <code>S(k)</code> for a single-component simulation.</p><p>This is the main implementation that computes <code>S(k) = (1/N) * &lt;|ρ(k)|^2&gt;</code> from the pre-computed density modes <code>ρkt</code>. The average is performed over time and k-vectors within the magnitude range <code>[kmin, kmax]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}</code>: The simulation data.</li><li><code>kspace::KSpace</code>: The pre-computed k-space.</li><li><code>ρkt::SingleComponentDensityModes</code>: The pre-computed density modes.</li><li><code>kmin::Float64=0.0</code>: The minimum magnitude of k-vectors to include in the average.</li><li><code>kmax::Float64=10.0^10.0</code>: The maximum magnitude of k-vectors to include in the average.</li></ul><p><strong>Returns</strong></p><ul><li><code>Sk::Float64</code>: The value of the structure factor <code>S(k)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/StructureFactors.jl#L84-L101">source</a></section><section><div><pre><code class="language-julia hljs">find_structure_factor(s::Union{MultiComponentSimulation,MCSPVSimulation}, kspace::KSpace, ρkt::MultiComponentDensityModes; kmin=0.0, kmax=10.0^10.0)</code></pre><p>Calculates the partial static structure factors <code>S_αβ(k)</code> for a multi-component simulation.</p><p>This function computes <code>S_αβ(k) = (1/N) * &lt;ρ_α(k) ρ_β*(-k)&gt;</code> from the pre-computed density modes <code>ρkt</code> for species <code>α</code> and <code>β</code>. The average is performed over time and k-vectors within the magnitude range <code>[kmin, kmax]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>s::Union{MultiComponentSimulation,MCSPVSimulation}</code>: The simulation data.</li><li><code>kspace::KSpace</code>: The pre-computed k-space.</li><li><code>ρkt::MultiComponentDensityModes</code>: The pre-computed density modes for all species.</li><li><code>kmin::Float64=0.0</code>: The minimum magnitude of k-vectors to include in the average.</li><li><code>kmax::Float64=10.0^10.0</code>: The maximum magnitude of k-vectors to include in the average.</li></ul><p><strong>Returns</strong></p><ul><li><code>Sk::Matrix{Float64}</code>: A matrix where <code>Sk[α, β]</code> is the partial structure factor <code>S_αβ(k)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/StructureFactors.jl#L108-L125">source</a></section></article><h2 id="Mean-Squared-Displacement"><a class="docs-heading-anchor" href="#Mean-Squared-Displacement">Mean Squared Displacement</a><a id="Mean-Squared-Displacement-1"></a><a class="docs-heading-anchor-permalink" href="#Mean-Squared-Displacement" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.find_mean_squared_displacement" href="#SimulationAnalysis.find_mean_squared_displacement"><code>SimulationAnalysis.find_mean_squared_displacement</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_mean_squared_displacement(simulation::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}; per_particle=false)</code></pre><p>Calculates the mean squared displacement (MSD) for a given simulation.</p><p>The MSD is defined as <code>&lt;|r(t) - r(0)|^2&gt;</code>, where the average is taken over all particles and time origins.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}</code>: The simulation data.</li><li><code>per_particle::Bool=false</code>: If <code>true</code>, the function returns the MSD calculated for each particle individually, in addition to the total MSD.</li><li><code>power::Int=2</code>: The power to which the displacement is raised. Default is 2 for MSD. Set to 4 for the mean quartic displacement of the displacement for example.</li></ul><p><strong>Returns</strong></p><p>If <code>per_particle</code> is <code>false</code> (default):</p><ul><li><code>msd::Vector{Float64}</code>: A vector containing the MSD for each time delay <code>Δt</code> in <code>simulation.dt_array</code>.</li></ul><p>If <code>per_particle</code> is <code>true</code>:</p><ul><li><code>msd::Vector{Float64}</code>: The total MSD vector.</li><li><code>msd_per_particle::Matrix{Float64}</code>: A <code>(N, N_dt)</code> matrix of MSDs for each particle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/MeanSquaredDisplacement.jl#L1-L20">source</a></section><section><div><pre><code class="language-julia hljs">find_mean_squared_displacement(simulation::Union{MultiComponentSimulation, MCSPVSimulation}; per_particle=false)</code></pre><p>Calculates the mean squared displacement (MSD) for a given simulation.</p><p>The MSD is defined as <code>&lt;|r(t) - r(0)|^2&gt;</code>, where the average is taken over all particles and time origins.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Union{MultiComponentSimulation, MCSPVSimulation}</code>: The simulation data.</li><li><code>power::Int=2</code>: The power to which the displacement is raised. Default is 2 for MSD. Set to 4 for the mean quartic displacement of the displacement for example.</li></ul><p><strong>Returns</strong></p><ul><li><code>msd::Vector{Float64}</code>: A vector containing the MSD for each time delay <code>Δt</code> in <code>simulation.dt_array</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/MeanSquaredDisplacement.jl#L30-L43">source</a></section><section><div><pre><code class="language-julia hljs">find_mean_squared_displacement(r, dt_array, t1_t2_pair_array)</code></pre><p>Calculates the mean squared displacement (MSD) using pre-calculated time pairs.</p><p>This is the core implementation for calculating the MSD. It iterates through particles and time pairs to compute the displacement.</p><p><strong>Arguments</strong></p><ul><li><code>r::Array{Float64, 3}</code>: A <code>(Ndims, N, N_timesteps)</code> array of particle positions.</li><li><code>dt_array::Vector{Int}</code>: An array of time step differences (<code>Δt</code>).</li><li><code>t1_t2_pair_array::Vector{Array{Int64, 2}}</code>: An array of <code>(t1, t2)</code> index pairs for each <code>Δt</code>.</li><li><code>power::Int=2</code>: The power to which the displacement is raised. </li></ul><p><strong>Returns</strong></p><ul><li><code>msd::Vector{Float64}</code>: A vector containing the MSD for each time delay <code>Δt</code> in <code>dt_array</code>.</li><li><code>msd_per_particle::Matrix{Float64}</code>: A <code>(N, N_dt)</code> matrix of MSDs for each particle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/MeanSquaredDisplacement.jl#L58-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.find_non_gaussian_parameter" href="#SimulationAnalysis.find_non_gaussian_parameter"><code>SimulationAnalysis.find_non_gaussian_parameter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_non_gaussian_parameter(simulation::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}; per_particle=false)</code></pre><p>Calculates the non-Gaussian parameter α2 for a given simulation.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}</code>: The simulation data.</li><li><code>per_particle::Bool=false</code>: If <code>true</code>, the function returns the non-Gaussian parameter calculated for each particle individually, in addition to the total non-Gaussian parameter.</li></ul><p><strong>Returns</strong></p><ul><li><code>α2::Float64</code>: The non-Gaussian parameter for the entire simulation.</li><li><code>α2_per_particle::Matrix{Float64}</code>: A <code>(N, N_dt)</code> matrix of non-Gaussian parameters for each particle, if <code>per_particle</code> is <code>true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/MeanSquaredDisplacement.jl#L120-L132">source</a></section></article><h2 id="Overlap-Function"><a class="docs-heading-anchor" href="#Overlap-Function">Overlap Function</a><a id="Overlap-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Overlap-Function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.find_overlap_function" href="#SimulationAnalysis.find_overlap_function"><code>SimulationAnalysis.find_overlap_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_overlap_function(s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}; a=0.5)</code></pre><p>Calculates the overlap function <code>Q(t)</code>.</p><p>The overlap function is a measure of the similarity between the particle configurations at time <code>0</code> and time <code>t</code>. It is defined as: <code>Q(t) = (1/N) * Σ_i θ(a - |r_i(t) - r_i(0)|)</code>, where <code>θ</code> is the Heaviside step function, <code>a</code> is a cutoff distance, and the average is taken over all particles <code>i</code> and time origins. A value of 1 means the configurations are identical (within the cutoff), and a value of 0 means they are completely different.</p><p><strong>Arguments</strong></p><ul><li><code>s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}</code>: The simulation data.</li><li><code>a::Float64=0.5</code>: The cutoff distance for calculating the overlap. Typically this is a fraction of the particle diameter.</li></ul><p><strong>Returns</strong></p><ul><li><code>Fs::Vector{Float64}</code>: A vector containing <code>Q(t)</code> for each time delay <code>Δt</code> in <code>s.dt_array</code>.</li><li><code>Fs_pp::Matrix{Float64}</code>: A <code>(Ndt, N)</code> matrix containing the overlap function for each particle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/OverlapFunction.jl#L1-L18">source</a></section></article><h2 id="Neighborlists"><a class="docs-heading-anchor" href="#Neighborlists">Neighborlists</a><a id="Neighborlists-1"></a><a class="docs-heading-anchor-permalink" href="#Neighborlists" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.find_relative_distance_neighborlists" href="#SimulationAnalysis.find_relative_distance_neighborlists"><code>SimulationAnalysis.find_relative_distance_neighborlists</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_relative_distance_neighborlists(s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}, rc::Float64; ζ::Float64 = 0.2)</code></pre><p>Finds neighbor lists for all time steps based on a relative distance criterion.</p><p>This method is suitable for polydisperse systems where particle diameters vary. Two particles <code>i</code> and <code>j</code> are considered neighbors if the distance between them is less than a cutoff that depends on their respective diameters <code>D_i</code> and <code>D_j</code>: <code>distance(i, j) &lt; rc * (D_i + D_j)/2 * (1 - ζ * abs(D_i - D_j))</code></p><p>This function requires the <code>D_array</code> (particle diameters) to be loaded in the <code>Simulation</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}</code>: The simulation data. Must contain particle diameters.</li><li><code>rc::Float64</code>: The relative cutoff distance.</li><li><code>ζ::Float64=0.2</code>: A non-additivity parameter to modulate the cutoff for particles of different sizes.</li></ul><p><strong>Returns</strong></p><ul><li><code>neighborlists::Vector{Vector{Vector{Int}}}</code>: A vector over time steps. For each time step, a vector over particles, where <code>neighborlists[t][i]</code> contains the list of neighbors of particle <code>i</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Neighborlists.jl#L2-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.find_absolute_distance_neighborlists" href="#SimulationAnalysis.find_absolute_distance_neighborlists"><code>SimulationAnalysis.find_absolute_distance_neighborlists</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_absolute_distance_neighborlists(s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}, rc::Float64)</code></pre><p>Finds neighbor lists for all time steps based on a fixed, absolute distance cutoff.</p><p>Two particles <code>i</code> and <code>j</code> are considered neighbors if the distance between them is less than <code>rc</code>. Periodic boundary conditions are taken into account.</p><p><strong>Arguments</strong></p><ul><li><code>s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}</code>: The simulation data.</li><li><code>rc::Float64</code>: The absolute cutoff distance.</li></ul><p><strong>Returns</strong></p><ul><li><code>neighborlists::Vector{Vector{Vector{Int}}}</code>: A vector over time steps. For each time step, a vector over particles, where <code>neighborlists[t][i]</code> contains the list of neighbors of particle <code>i</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Neighborlists.jl#L69-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.find_voronoi_neighborlists" href="#SimulationAnalysis.find_voronoi_neighborlists"><code>SimulationAnalysis.find_voronoi_neighborlists</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_voronoi_neighborlists(s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}; max_distance_from_boundary=3.0, verbose=true, indices=eachindex(s.t_array))</code></pre><p>Computes neighbor lists based on Voronoi tessellation for each time step.</p><p>Two particles are considered neighbors if their Voronoi cells are adjacent (i.e., share a facet). This method uses the <code>Quickhull.jl</code> package to perform the Delaunay triangulation, which is the dual of the Voronoi tessellation.</p><p><strong>Arguments</strong></p><ul><li><code>s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}</code>: The simulation data.</li><li><code>max_distance_from_boundary::Float64=3.0</code>: How far from the central box to consider periodic images for the tessellation. This should be large enough to avoid boundary effects.</li><li><code>verbose::Bool=true</code>: If <code>true</code>, prints progress information.</li><li><code>indices=eachindex(s.t_array)</code>: The range of time step indices to analyze. Defaults to all time steps.</li></ul><p><strong>Returns</strong></p><ul><li><code>neighborlists::Vector{Vector{Vector{Int}}}</code>: A vector over time steps. For each time step, a vector over particles, where <code>neighborlists[t][i]</code> contains the list of neighbors of particle <code>i</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Neighborlists.jl#L213-L229">source</a></section></article><h2 id="Bond-Breaking-Parameter"><a class="docs-heading-anchor" href="#Bond-Breaking-Parameter">Bond Breaking Parameter</a><a id="Bond-Breaking-Parameter-1"></a><a class="docs-heading-anchor-permalink" href="#Bond-Breaking-Parameter" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.find_CB" href="#SimulationAnalysis.find_CB"><code>SimulationAnalysis.find_CB</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_CB(s::Simulation, neighbourlists1::Vector{&lt;:Vector}, neighbourlists2::Vector{&lt;:Vector})</code></pre><p>Calculates the bond-breaking correlation function <code>C_B(t)</code> for all particles.</p><p>This function measures the fraction of neighbors that a particle at time <code>t_0</code> still has at a later time <code>t_0 + t</code>. It is averaged over all particles and time origins <code>t_0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>s::Simulation</code>: The simulation data, used for time information.</li><li><code>neighbourlists1::Vector{&lt;:Vector}</code>: A vector of neighbor lists at the initial times (<code>t_0</code>).</li><li><code>neighbourlists2::Vector{&lt;:Vector}</code>: A vector of neighbor lists at the final times (<code>t_0 + t</code>). Often, this is the same as <code>neighbourlists1</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>CB::Matrix{Float64}</code>: A <code>(Ndt, N)</code> matrix where <code>CB[i, j]</code> is the bond-breaking correlation for particle <code>j</code> at time delay <code>dt_array[i]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/BondBreakingParameter.jl#L66-L81">source</a></section></article><h2 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.find_relaxation_time" href="#SimulationAnalysis.find_relaxation_time"><code>SimulationAnalysis.find_relaxation_time</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_relaxation_time(t::AbstractVector, F::AbstractVector; threshold::Float64=exp(-1))</code></pre><p>Calculates the relaxation time <code>τ</code> of a decaying function <code>F(t)</code>.</p><p>The relaxation time is defined as the time at which <code>F(t)</code> first drops below a certain <code>threshold</code>. The function finds this time by performing linear interpolation between the two points straddling the threshold. The interpolation is linear in <code>F</code> and <code>log(t)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>t::AbstractVector</code>: A vector of time points.</li><li><code>F::AbstractVector</code>: A vector of the function values <code>F(t)</code>, corresponding to the time points in <code>t</code>. This function should be monotonically decreasing.</li><li><code>threshold::Float64=exp(-1)</code>: The threshold value for <code>F(t)</code>. The relaxation time is <code>t</code> such that <code>F(t) = threshold</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>τ::Float64</code>: The calculated relaxation time. Returns <code>0.0</code> if the function is already below the threshold at the first time point. Returns <code>Inf</code> if the function never drops below the threshold.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/Utils.jl#L1-L16">source</a></section></article><h2 id="Radial-Distribution-Function"><a class="docs-heading-anchor" href="#Radial-Distribution-Function">Radial Distribution Function</a><a id="Radial-Distribution-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Radial-Distribution-Function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SimulationAnalysis.find_radial_distribution_function" href="#SimulationAnalysis.find_radial_distribution_function"><code>SimulationAnalysis.find_radial_distribution_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_radial_distribution_function(s::Union{MultiComponentSimulation,MCSPVSimulation}, Nbins::Int, rmax::Float64; Ntasks=1, verbose=true)</code></pre><p>Calculates the partial radial distribution functions <code>g_αβ(r)</code> for a multi-component simulation.</p><p>The <code>g_αβ(r)</code> describes the probability of finding a particle of species <code>β</code> at a distance <code>r</code> from a particle of species <code>α</code>, relative to that of an ideal gas.</p><p><strong>Arguments</strong></p><ul><li><code>s::Union{MultiComponentSimulation,MCSPVSimulation}</code>: The simulation data.</li><li><code>Nbins::Int</code>: The number of bins to use for the histogram.</li><li><code>rmax::Float64</code>: The maximum distance to consider. If negative, it&#39;s set to half the smallest box dimension.</li><li><code>Ntasks::Int=1</code>: The number of parallel tasks to use for the calculation.</li><li><code>verbose::Bool=true</code>: If <code>true</code>, prints progress to the console.</li></ul><p><strong>Returns</strong></p><ul><li><code>bin_centres::Vector{Float64}</code>: A vector of the centre points of the histogram bins.</li><li><code>g_r::Matrix{Vector{Float64}}</code>: A matrix of vectors, where <code>g_r[α, β]</code> is the partial <code>g_αβ(r)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/RadialDistributionFunction.jl#L134-L151">source</a></section><section><div><pre><code class="language-julia hljs">find_radial_distribution_function(s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}, Nbins::Int, rmax::Float64; Ntasks::Int=1, verbose=true)</code></pre><p>Calculates the radial distribution function <code>g(r)</code> for a single-component simulation.</p><p>The <code>g(r)</code> describes the probability of finding a particle at a distance <code>r</code> from another particle, relative to that of an ideal gas.</p><p><strong>Arguments</strong></p><ul><li><code>s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}</code>: The simulation data.</li><li><code>Nbins::Int</code>: The number of bins to use for the histogram.</li><li><code>rmax::Float64</code>: The maximum distance to consider. If negative, it&#39;s set to half the smallest box dimension.</li><li><code>Ntasks::Int=1</code>: The number of parallel tasks to use for the calculation.</li><li><code>verbose::Bool=true</code>: If <code>true</code>, prints progress to the console.</li></ul><p><strong>Returns</strong></p><ul><li><code>bin_centres::Vector{Float64}</code>: A vector of the centre points of the histogram bins.</li><li><code>g_r::Vector{Float64}</code>: A vector containing the values of <code>g(r)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/RadialDistributionFunction.jl#L169-L186">source</a></section><section><div><pre><code class="language-julia hljs">find_radial_distribution_function(s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}, dr::Float64, rmax::Float64; Ntasks::Int=1, verbose=true)</code></pre><p>Calculates the radial distribution function <code>g(r)</code> for a single-component simulation.</p><p>This method defines the histogram bins by a fixed width <code>dr</code>.</p><p><strong>Arguments</strong></p><ul><li><code>s::Union{SingleComponentSimulation, SelfPropelledVoronoiSimulation}</code>: The simulation data.</li><li><code>dr::Float64</code>: The width of the histogram bins.</li><li><code>rmax::Float64</code>: The maximum distance to consider. If negative, it&#39;s set to half the smallest box dimension.</li><li><code>Ntasks::Int=1</code>: The number of parallel tasks to use for the calculation.</li><li><code>verbose::Bool=true</code>: If <code>true</code>, prints progress to the console.</li></ul><p><strong>Returns</strong></p><ul><li><code>bin_centres::Vector{Float64}</code>: A vector of the centre points of the histogram bins.</li><li><code>g_r::Vector{Float64}</code>: A vector containing the values of <code>g(r)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SimulationAnalysis.jl/blob/cb95060b7f43ffdec61e52492a05852a258c065f/src/RadialDistributionFunction.jl#L203-L220">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 15 August 2025 14:10">Friday 15 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
