var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/#Simulation","page":"API","title":"Simulation","text":"","category":"section"},{"location":"api/#SimulationAnalysis.SingleComponentSimulation","page":"API","title":"SimulationAnalysis.SingleComponentSimulation","text":"SingleComponentSimulation\n\nA mutable struct that holds all data for a single-component particle simulation.\n\nFields\n\nN::Int64: Number of particles.\nNdims::Int64: Number of spatial dimensions.\nr_array::Array{Float64, 3}: Particle positions. The dimensions of the array are (N, Ndims, N_time_steps).\nv_array::Array{Float64, 3}: Particle velocities. The dimensions of the array are (N, Ndims, N_time_steps).\nF_array::Array{Float64, 3}: Forces on particles. The dimensions of the array are (N, Ndims, N_time_steps).\nD_array::Array{Float64, 1}: Diffusion coefficient for each particle.\nt_array::Array{Float64, 1}: Vector of time points corresponding to each time step.\nbox_sizes::Vector{Float64}: A vector holding the simulation box dimensions, e.g., [Lx, Ly, Lz].\ndt_array::Array{Int64, 1}: An array of time step differences (Δt) used for calculating time correlation functions.\nt1_t2_pair_array::Vector{Array{Int64, 2}}: An array of (t1, t2) index pairs, used for efficient calculation of time correlations.\nfilepath::String: Path to the file from which the simulation data was loaded.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationAnalysis.MultiComponentSimulation","page":"API","title":"SimulationAnalysis.MultiComponentSimulation","text":"MultiComponentSimulation\n\nA mutable struct that holds all data for a multi-component particle simulation.\n\nFields\n\nN::Int64: Total number of particles across all species.\nNdims::Int64: Number of spatial dimensions.\nN_species::Int64: Number of different particle species.\nN_particles_per_species::Vector{Int}: A vector containing the number of particles for each species.\nr_array::Vector{Array{Float64, 3}}: A vector of particle position arrays. Each element r_array[i] is a (N_particles_per_species[i], Ndims, N_time_steps) array for species i.\nv_array::Vector{Array{Float64, 3}}: A vector of particle velocity arrays for each species.\nF_array::Vector{Array{Float64, 3}}: A vector of particle force arrays for each species.\nt_array::Vector{Float64}: Vector of time points corresponding to each time step.\nbox_sizes::Vector{Float64}: A vector holding the simulation box dimensions, e.g., [Lx, Ly, Lz].\ndt_array::Vector{Int}: An array of time step differences (Δt) used for calculating time correlation functions.\nt1_t2_pair_array::Vector{Array{Int64, 2}}: An array of (t1, t2) index pairs, used for efficient calculation of time correlations.\nfilepath::String: Path to the file from which the simulation data was loaded.\n\n\n\n\n\n","category":"type"},{"location":"api/#K-Space","page":"API","title":"K-Space","text":"","category":"section"},{"location":"api/#SimulationAnalysis.KSpace","page":"API","title":"SimulationAnalysis.KSpace","text":"KSpace{dims, S, OA}\n\nA struct to hold the reciprocal space (k-space) vectors for a simulation.\n\nThis struct is usually created via construct_k_space.\n\nFields\n\ns::S: The Simulation object for which the k-space is defined.\nNk::Int64: The total number of k-vectors.\nk_lengths::Vector{Float64}: A vector of length Nk containing the magnitude of each k-vector.\nk_array::Matrix{Float64}: A (dims, Nk) matrix where each column is a k-vector (kx, ky, kz, ...).\nkfactor::Int64: An integer scaling factor used to determine the resolution of the k-space grid. A higher factor means a courser grid.\ncartesian_to_linear::OA: An OffsetArray that maps the Cartesian grid indices (ix, iy, iz, ...) of a k-vector to its linear index in k_lengths and k_array.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationAnalysis.construct_k_space","page":"API","title":"SimulationAnalysis.construct_k_space","text":"construct_k_space(s::Simulation, bounds; kfactor=1, negative=false, rectangular=false)\n\nConstructs the k-space for a given simulation.\n\nThis function generates a set of k-vectors based on the simulation box and specified parameters. The k-vectors are chosen from a grid with spacing 2π/L * kfactor, where L is the box size in each dimension.\n\nArguments\n\ns::Simulation: The simulation object (SingleComponentSimulation or MultiComponentSimulation).\nbounds: A tuple or vector (kmin, kmax) specifying the range of magnitudes for the k-vectors. k-vectors with magnitude k such that kmin < k < kmax are included.\n\nKeyword Arguments\n\nkfactor::Int=1: An integer scaling factor for the k-vector grid resolution.\nnegative::Bool=false: If true, includes k-vectors with negative components for the first d-1 dimensions.\nrectangular::Bool=false: If true, a rectangular k-space grid is generated, and all k-vectors within the grid up to kmax are included, ignoring kmin. If false, k-vectors are selected from a spherical shell.\n\nReturns\n\nA KSpace object containing the generated k-vectors and related information.\n\nSee also: KSpace\n\n\n\n\n\n","category":"function"},{"location":"api/#Correlation-Function","page":"API","title":"Correlation Function","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_correlation_function","page":"API","title":"SimulationAnalysis.find_correlation_function","text":"find_correlation_function(A, B, s)\n\nComputes the correlation function between two lists of observables. The observables are assumed to be complex-valued. The correlation function is a complex number. The correlation function is averaged over the first dimension of A and B.\n\nArguments\n\nA::Array{Complex{Float64}, 2}: The first list of observables.\nB::Array{Complex{Float64}, 2}: The second list of observables.\ns::Simulation: The simulation.\n\nReturns\n\nC::Array{Complex{Float64}, 1}: The correlation function.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationAnalysis.find_correlation_matrix","page":"API","title":"SimulationAnalysis.find_correlation_matrix","text":"find_correlation_matrix(observables_list1, observables_list2, kspace, s)\n\nComputes the correlation matrix between two lists of observables. The observables are assumed to be complex-valued. The correlation matrix is a matrix of complex numbers.\n\nArguments\n\nobservables_list1::Array{Array{Complex{Float64}, 2}, 1}: The first list of observables.\nobservables_list2::Array{Array{Complex{Float64}, 2}, 1}: The second list of observables.\ns::Simulation: The simulation.\n\nReturns\n\nmatrix::Array{Array{Complex{Float64}, 1}, 2}: The correlation matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#Density-Modes","page":"API","title":"Density Modes","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_density_modes","page":"API","title":"SimulationAnalysis.find_density_modes","text":"find_density_modes(s::SingleComponentSimulation, kspace::KSpace; verbose=true)\n\nCalculates the density modes ρ(k,t) = Σ_j exp(i * k ⋅ r_j(t)) for a single-component simulation.\n\nThe calculation is performed for all k-vectors in kspace and for all time steps in the simulation. This function is computationally intensive. The verbose option can be used to monitor progress.\n\nArguments\n\ns::SingleComponentSimulation: The simulation data.\nkspace::KSpace: The k-space vectors for which to calculate the density modes.\nverbose::Bool=true: If true, prints progress and performance information to the console.\n\nReturns\n\nSingleComponentDensityModes: A struct containing the real and imaginary parts of the density modes.\n\nSee also: SingleComponentDensityModes, find_density_modes(::MultiComponentSimulation, ::KSpace)\n\n\n\n\n\nfind_density_modes(s::MultiComponentSimulation, kspace::KSpace; verbose=true)\n\nCalculates the density modes ρ_s(k,t) = Σ_j exp(i * k ⋅ r_j(t)) for each species s in a multi-component simulation.\n\nThe calculation is performed for all k-vectors in kspace and for all time steps in the simulation. This function is computationally intensive. The verbose option can be used to monitor progress.\n\nArguments\n\ns::MultiComponentSimulation: The simulation data.\nkspace::KSpace: The k-space vectors for which to calculate the density modes.\nverbose::Bool=true: If true, prints progress and performance information to the console.\n\nReturns\n\nMultiComponentDensityModes: A struct containing the real and imaginary parts of the density modes for each species.\n\nSee also: MultiComponentDensityModes, find_density_modes(::SingleComponentSimulation, ::KSpace)\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationAnalysis.SingleComponentDensityModes","page":"API","title":"SimulationAnalysis.SingleComponentDensityModes","text":"SingleComponentDensityModes\n\nA struct to hold the density modes ρ(k,t) for a single-component simulation.\n\nThe density modes are defined as ρ(k,t) = Σ_j exp(i * k ⋅ r_j(t)), where the sum is over all particles j. This struct stores the real and imaginary parts of ρ(k,t) for various k-vectors and time steps.\n\nFields\n\nRe::Matrix{Float64}: The real part of the density modes, Σ_j cos(k ⋅ rj). Dimensions are (N_timesteps, Nk).\nIm::Matrix{Float64}: The imaginary part of the density modes, Σ_j sin(k ⋅ rj). Dimensions are (N_timesteps, Nk).\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationAnalysis.MultiComponentDensityModes","page":"API","title":"SimulationAnalysis.MultiComponentDensityModes","text":"MultiComponentDensityModes\n\nA struct to hold the density modes ρ_s(k,t) for each species s in a multi-component simulation.\n\nThe density modes for each species are defined as ρ_s(k,t) = Σ_j exp(i * k ⋅ r_j(t)), where the sum is over all particles j of species s. This struct stores the real and imaginary parts of ρ_s(k,t) for various k-vectors and time steps.\n\nFields\n\nRe::Vector{Matrix{Float64}}: A vector where Re[s] is the real part of the density modes for species s. Each matrix has dimensions (N_timesteps, Nk).\nIm::Vector{Matrix{Float64}}: A vector where Im[s] is the imaginary part of the density modes for species s. Each matrix has dimensions (N_timesteps, Nk).\n\n\n\n\n\n","category":"type"},{"location":"api/#Forces","page":"API","title":"Forces","text":"","category":"section"},{"location":"api/#SimulationAnalysis.Weysser","page":"API","title":"SimulationAnalysis.Weysser","text":"Weysser <: InteractionPotential\n\nA struct for the Weysser interaction potential.\n\nFields\n\nϵ::Float64: The interaction strength.\nδ::Float64: The interaction range.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationAnalysis.Berthier","page":"API","title":"SimulationAnalysis.Berthier","text":"Berthier <: InteractionPotential\n\nA struct for the Berthier interaction potential.\n\nFields\n\nc0::Float64: The c0 coefficient.\nc2::Float64: The c2 coefficient.\nc4::Float64: The c4 coefficient.\nζ::Float64: The zeta coefficient.\nσ_ratio::Float64: The ratio of the diameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationAnalysis.WCA","page":"API","title":"SimulationAnalysis.WCA","text":"WCA <: InteractionPotential\n\nA struct for the WCA interaction potential.\n\nFields\n\nϵ::Float64: The interaction strength.\nσ::Float64: The interaction range.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationAnalysis.KAWCA","page":"API","title":"SimulationAnalysis.KAWCA","text":"KAWCA <: InteractionPotential\n\nA struct for the Kob-Andersen WCA interaction potential.\n\nFields\n\nϵ11::Float64: The interaction strength between particles of type 1.\nϵ12::Float64: The interaction strength between particles of type 1 and 2.\nϵ22::Float64: The interaction strength between particles of type 2.\nσ11::Float64: The interaction range between particles of type 1.\nσ12::Float64: The interaction range between particles of type 1 and 2.\nσ22::Float64: The interaction range between particles of type 2.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationAnalysis.calculate_forces!","page":"API","title":"SimulationAnalysis.calculate_forces!","text":"calculate_forces!(s, forcestype::Bool)\n\nCalculate the forces for a simulation.\n\nThis is a placeholder function that throws an error if forcestype is true.\n\nArguments\n\ns: The simulation object.\nforcestype::Bool: Whether to calculate forces.\n\n\n\n\n\ncalculate_forces!(s, U; friction=false, cutoff=1.25)\n\nRecalculates the total force on all particles according to the langevin equation F = -∇U - γv. This function also updates the total potential energy in the output datastructure.\n\n\n\n\n\ncalculate_forces!(s, U::KAWCA; cutoff=2.0^(1.0/6.0))\n\nRecalculates the total force on all particles in a multi-component simulation s according to the Kob-Andersen Weeks-Chandler-Andersen system U, and updates the force array in s with the calculated values.\n\nArguments\n\ns: a MultiComponentSimulation object that contains the position and force arrays for each particle.\nU::KAWCA: the interaction type.\ncutoff: the cutoff distance for the potential energy function. Default is 2.0^(1.0/6.0).\n\n\n\n\n\n","category":"function"},{"location":"api/#Intermediate-Scattering-Function","page":"API","title":"Intermediate Scattering Function","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_intermediate_scattering_function","page":"API","title":"SimulationAnalysis.find_intermediate_scattering_function","text":"find_intermediate_scattering_function(s::Simulation; kmin=7.0, kmax=7.4, kfactor=1)\n\nCalculates the coherent intermediate scattering function F(k, t) for a simulation, averaged over a shell in k-space.\n\nThis is a convenience function that first constructs the k-space and density modes, and then computes F(k, t). The function is defined as: F(k, t) = (1/N) * < Σ_{i,j} exp(i * k ⋅ (r_i(t) - r_j(0))) >. The average is taken over time origins and over k-vectors with magnitudes k such that kmin < k < kmax.\n\nArguments\n\ns::Simulation: The simulation data.\nkmin::Float64=7.0: The minimum magnitude of the k-vectors to be included in the average.\nkmax::Float64=7.4: The maximum magnitude of the k-vectors to be included in the average.\nkfactor::Int=1: The resolution factor for the k-space grid.\n\nReturns\n\nFk: The intermediate scattering function. For a SingleComponentSimulation, this is a Vector{Float64}. For a MultiComponentSimulation, this is a Matrix{Vector{Float64}}.\n\n\n\n\n\nfind_intermediate_scattering_function(s::Simulation, kspace::KSpace, ρkt, k_sample_array::AbstractVector; k_binwidth=0.1)\n\nCalculates the coherent intermediate scattering function F(k, t) for a list of specified k values.\n\nFor each k in k_sample_array, this function computes F(k, t) by averaging over a k-shell of width k_binwidth centered at k.\n\nArguments\n\ns::Simulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nρkt: The pre-computed density modes (SingleComponentDensityModes or MultiComponentDensityModes).\nk_sample_array::AbstractVector: A vector of k-magnitudes for which to compute F(k, t).\nk_binwidth::Float64=0.1: The width of the k-shell to average over for each value in k_sample_array.\n\nReturns\n\nF_array::Vector: A vector where F_array[i] is the F(k,t) corresponding to k_sample_array[i].\n\n\n\n\n\nfind_intermediate_scattering_function(s::SingleComponentSimulation, kspace::KSpace, ρkt::SingleComponentDensityModes; kmin=0.0, kmax=10.0^10.0)\n\nCalculates the coherent intermediate scattering function F(k, t) for a single-component simulation.\n\nThis is the main implementation that computes F(k, t) = (1/N) * <ρ(k, t) ρ*(-k, 0)> by correlating the pre-computed density modes ρkt. The average is performed over time origins and k-vectors within the magnitude range [kmin, kmax].\n\nArguments\n\ns::SingleComponentSimulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nρkt::SingleComponentDensityModes: The pre-computed density modes.\nkmin::Float64=0.0: The minimum magnitude of k-vectors to include in the average.\nkmax::Float64=10.0^10.0: The maximum magnitude of k-vectors to include in the average.\n\nReturns\n\nFk::Vector{Float64}: A vector containing F(k, t) for each time delay Δt in s.dt_array.\n\n\n\n\n\nfind_intermediate_scattering_function(s::MultiComponentSimulation, kspace::KSpace, ρkt::MultiComponentDensityModes; kmin=0.0, kmax=10.0^10.0)\n\nCalculates the partial intermediate scattering functions F_αβ(k, t) for a multi-component simulation.\n\nThis function computes F_αβ(k, t) = (1/N) * <ρ_α(k, t) ρ_β*(-k, 0)> by correlating the pre-computed density modes ρkt for species α and β. The average is performed over time origins and k-vectors within the magnitude range [kmin, kmax].\n\nArguments\n\ns::MultiComponentSimulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nρkt::MultiComponentDensityModes: The pre-computed density modes for all species.\nkmin::Float64=0.0: The minimum magnitude of k-vectors to include in the average.\nkmax::Float64=10.0^10.0: The maximum magnitude of k-vectors to include in the average.\n\nReturns\n\nFk::Matrix{Vector{Float64}}: A matrix of vectors, where Fk[α, β] is the partial intermediate scattering function F_αβ(k, t).\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationAnalysis.find_self_intermediate_scattering_function","page":"API","title":"SimulationAnalysis.find_self_intermediate_scattering_function","text":"find_self_intermediate_scattering_function(s::Simulation; kmin=7.0, kmax=7.4, kfactor=1)\n\nCalculates the self-intermediate scattering function Fs(k, t), averaged over a shell in k-space.\n\nThis is a convenience function that first constructs the k-space and then computes Fs(k, t). The function is defined as: Fs(k, t) = (1/N) * <Σ_j exp(i * k ⋅ (r_j(t) - r_j(0)))>. The average is taken over time origins and over k-vectors with magnitudes k such that kmin < k < kmax. This function is only implemented for SingleComponentSimulation.\n\nArguments\n\ns::Simulation: The simulation data.\nkmin::Float64=7.0: The minimum magnitude of the k-vectors to be included in the average.\nkmax::Float64=7.4: The maximum magnitude of the k-vectors to be included in the average.\nkfactor::Int=1: The resolution factor for the k-space grid.\n\nReturns\n\nFk::Vector{Float64}: A vector containing Fs(k, t) for each time delay Δt in s.dt_array.\nFks_per_particle::Matrix{Float64}: A (Ndt, N) matrix containing the self-intermediate scattering function for each particle.\n\n\n\n\n\nfind_self_intermediate_scattering_function(s::Simulation, kspace::KSpace, k_sample_array::AbstractVector; k_binwidth=0.1)\n\nCalculates the self-intermediate scattering function Fs(k, t) for a list of specified k values.\n\nFor each k in k_sample_array, this function computes Fs(k, t) by averaging over a k-shell of width k_binwidth centered at k. This function is only implemented for SingleComponentSimulation.\n\nArguments\n\ns::Simulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nk_sample_array::AbstractVector: A vector of k-magnitudes for which to compute Fs(k, t).\nk_binwidth::Float64=0.1: The width of the k-shell to average over for each value in k_sample_array.\n\nReturns\n\nF_array::Vector: A vector of tuples (Fk, Fks_per_particle) for each k in k_sample_array.\n\n\n\n\n\nfind_self_intermediate_scattering_function(s::SingleComponentSimulation, kspace::KSpace; kmin=0.0, kmax=10.0^10.0)\n\nCalculates the self-intermediate scattering function Fs(k, t) for a single-component simulation.\n\nThis is the main implementation that computes Fs(k, t) = (1/N) * <Σ_j exp(i * k ⋅ (r_j(t) - r_j(0)))>. The calculation is done without pre-calculating density modes to avoid large memory allocation. The average is performed over time origins and k-vectors within the magnitude range [kmin, kmax].\n\nArguments\n\ns::SingleComponentSimulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nkmin::Float64=0.0: The minimum magnitude of k-vectors to include in the average.\nkmax::Float64=10.0^10.0: The maximum magnitude of k-vectors to include in the average.\n\nReturns\n\nFk::Vector{Float64}: A vector containing Fs(k, t) for each time delay Δt in s.dt_array.\nFks_per_particle::Matrix{Float64}: A (Ndt, N) matrix containing the self-intermediate scattering function for each particle.\n\n\n\n\n\n","category":"function"},{"location":"api/#Structure-Factors","page":"API","title":"Structure Factors","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_structure_factor","page":"API","title":"SimulationAnalysis.find_structure_factor","text":"find_structure_factor(s::Simulation; kmin=7.0, kmax=7.4, kfactor=1)\n\nCalculates the static structure factor S(k) for a simulation, averaged over a shell in k-space.\n\nThis is a convenience function that first constructs the k-space and density modes, and then computes S(k). The function is defined as: S(k) = (1/N) * <|Σ_j exp(i * k ⋅ r_j)|^2>. The average is taken over time and over k-vectors with magnitudes k such that kmin < k < kmax.\n\nArguments\n\ns::Simulation: The simulation data.\nkmin::Float64=7.0: The minimum magnitude of the k-vectors to be included in the average.\nkmax::Float64=7.4: The maximum magnitude of the k-vectors to be included in the average.\nkfactor::Int=1: The resolution factor for the k-space grid.\n\nReturns\n\nSk: The structure factor. For a SingleComponentSimulation, this is a Float64. For a MultiComponentSimulation, this is a Matrix{Float64}.\n\n\n\n\n\nfind_structure_factor(s::Simulation, kspace::KSpace, ρkt::AbstractDensityModes, k_sample_array::AbstractVector; k_binwidth=0.1)\n\nCalculates the static structure factor S(k) for a list of specified k values.\n\nFor each k in k_sample_array, this function computes S(k) by averaging over a k-shell of width k_binwidth centered at k.\n\nArguments\n\ns::Simulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nρkt::AbstractDensityModes: The pre-computed density modes.\nk_sample_array::AbstractVector: A vector of k-magnitudes for which to compute S(k).\nk_binwidth::Float64=0.1: The width of the k-shell to average over for each value in k_sample_array.\n\nReturns\n\nS_array::Vector: A vector where S_array[i] is the S(k) corresponding to k_sample_array[i].\n\n\n\n\n\nfind_structure_factor(s::SingleComponentSimulation, kspace::KSpace, ρkt::SingleComponentDensityModes; kmin=0.0, kmax=10.0^10.0)\n\nCalculates the static structure factor S(k) for a single-component simulation.\n\nThis is the main implementation that computes S(k) = (1/N) * <|ρ(k)|^2> from the pre-computed density modes ρkt. The average is performed over time and k-vectors within the magnitude range [kmin, kmax].\n\nArguments\n\ns::SingleComponentSimulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nρkt::SingleComponentDensityModes: The pre-computed density modes.\nkmin::Float64=0.0: The minimum magnitude of k-vectors to include in the average.\nkmax::Float64=10.0^10.0: The maximum magnitude of k-vectors to include in the average.\n\nReturns\n\nSk::Float64: The value of the structure factor S(k).\n\n\n\n\n\nfind_structure_factor(s::MultiComponentSimulation, kspace::KSpace, ρkt::MultiComponentDensityModes; kmin=0.0, kmax=10.0^10.0)\n\nCalculates the partial static structure factors S_αβ(k) for a multi-component simulation.\n\nThis function computes S_αβ(k) = (1/N) * <ρ_α(k) ρ_β*(-k)> from the pre-computed density modes ρkt for species α and β. The average is performed over time and k-vectors within the magnitude range [kmin, kmax].\n\nArguments\n\ns::MultiComponentSimulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nρkt::MultiComponentDensityModes: The pre-computed density modes for all species.\nkmin::Float64=0.0: The minimum magnitude of k-vectors to include in the average.\nkmax::Float64=10.0^10.0: The maximum magnitude of k-vectors to include in the average.\n\nReturns\n\nSk::Matrix{Float64}: A matrix where Sk[α, β] is the partial structure factor S_αβ(k).\n\n\n\n\n\n","category":"function"},{"location":"api/#Mean-Squared-Displacement","page":"API","title":"Mean Squared Displacement","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_mean_squared_displacement","page":"API","title":"SimulationAnalysis.find_mean_squared_displacement","text":"find_mean_squared_displacement(simulation::Simulation; per_particle=false)\n\nCalculates the mean squared displacement (MSD) for a given simulation.\n\nThe MSD is defined as <|r(t) - r(0)|^2>, where the average is taken over all particles and time origins.\n\nArguments\n\nsimulation::Simulation: The simulation data.\nper_particle::Bool=false: If true, the function returns the MSD calculated for each particle individually, in addition to the total MSD.\n\nReturns\n\nIf per_particle is false (default):\n\nmsd::Vector{Float64}: A vector containing the MSD for each time delay Δt in simulation.dt_array.\n\nIf per_particle is true:\n\nmsd::Vector{Float64}: The total MSD vector.\nmsd_per_particle::Matrix{Float64}: A (N, N_dt) matrix of MSDs for each particle.\n\n\n\n\n\nfind_mean_squared_displacement(r, dt_array, t1_t2_pair_array)\n\nCalculates the mean squared displacement (MSD) using pre-calculated time pairs.\n\nThis is the core implementation for calculating the MSD. It iterates through particles and time pairs to compute the displacement.\n\nArguments\n\nr::Array{Float64, 3}: A (Ndims, N, N_timesteps) array of particle positions.\ndt_array::Vector{Int}: An array of time step differences (Δt).\nt1_t2_pair_array::Vector{Array{Int64, 2}}: An array of (t1, t2) index pairs for each Δt.\n\nReturns\n\nmsd::Vector{Float64}: A vector containing the MSD for each time delay Δt in dt_array.\nmsd_per_particle::Matrix{Float64}: A (N, N_dt) matrix of MSDs for each particle.\n\n\n\n\n\n","category":"function"},{"location":"api/#Overlap-Function","page":"API","title":"Overlap Function","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_overlap_function","page":"API","title":"SimulationAnalysis.find_overlap_function","text":"find_overlap_function(s::Simulation; a=0.5)\n\nCalculates the overlap function Q(t).\n\nThe overlap function is a measure of the similarity between the particle configurations at time 0 and time t. It is defined as: Q(t) = (1/N) * Σ_i θ(a - |r_i(t) - r_i(0)|), where θ is the Heaviside step function, a is a cutoff distance, and the average is taken over all particles i and time origins. A value of 1 means the configurations are identical (within the cutoff), and a value of 0 means they are completely different.\n\nArguments\n\ns::Simulation: The simulation data.\na::Float64=0.5: The cutoff distance for calculating the overlap. Typically this is a fraction of the particle diameter.\n\nReturns\n\nFs::Vector{Float64}: A vector containing Q(t) for each time delay Δt in s.dt_array.\nFs_pp::Matrix{Float64}: A (Ndt, N) matrix containing the overlap function for each particle.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neighborlists","page":"API","title":"Neighborlists","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_relative_distance_neighborlists","page":"API","title":"SimulationAnalysis.find_relative_distance_neighborlists","text":"find_relative_distance_neighborlists(s::SingleComponentSimulation, rc::Float64; ζ::Float64 = 0.2)\n\nFinds neighbor lists for all time steps based on a relative distance criterion.\n\nThis method is suitable for polydisperse systems where particle diameters vary. Two particles i and j are considered neighbors if the distance between them is less than a cutoff that depends on their respective diameters D_i and D_j: distance(i, j) < rc * (D_i + D_j)/2 * (1 - ζ * abs(D_i - D_j))\n\nThis function requires the D_array (particle diameters) to be loaded in the Simulation object.\n\nArguments\n\ns::SingleComponentSimulation: The simulation data. Must contain particle diameters.\nrc::Float64: The relative cutoff distance.\nζ::Float64=0.2: A parameter to modulate the cutoff for particles of different sizes.\n\nReturns\n\nneighborlists::Vector{Vector{Vector{Int}}}: A vector over time steps. For each time step, a vector over particles, where neighborlists[t][i] contains the list of neighbors of particle i.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationAnalysis.find_absolute_distance_neighborlists","page":"API","title":"SimulationAnalysis.find_absolute_distance_neighborlists","text":"find_absolute_distance_neighborlists(s::Simulation, rc::Float64)\n\nFinds neighbor lists for all time steps based on a fixed, absolute distance cutoff.\n\nTwo particles i and j are considered neighbors if the distance between them is less than rc. Periodic boundary conditions are taken into account.\n\nArguments\n\ns::Simulation: The simulation data.\nrc::Float64: The absolute cutoff distance.\n\nReturns\n\nneighborlists::Vector{Vector{Vector{Int}}}: A vector over time steps. For each time step, a vector over particles, where neighborlists[t][i] contains the list of neighbors of particle i.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationAnalysis.find_voronoi_neighborlists","page":"API","title":"SimulationAnalysis.find_voronoi_neighborlists","text":"find_voronoi_neighborlists(s::Simulation; max_distance_from_boundary=3.0, verbose=true, indices=eachindex(s.t_array))\n\nComputes neighbor lists based on Voronoi tessellation for each time step.\n\nTwo particles are considered neighbors if their Voronoi cells are adjacent (i.e., share a facet). This method uses the Quickhull.jl package to perform the Delaunay triangulation, which is the dual of the Voronoi tessellation.\n\nArguments\n\ns::Simulation: The simulation data.\nmax_distance_from_boundary::Float64=3.0: How far from the central box to consider periodic images for the tessellation. This should be large enough to avoid boundary effects.\nverbose::Bool=true: If true, prints progress information.\nindices=eachindex(s.t_array): The range of time step indices to analyze. Defaults to all time steps.\n\nReturns\n\nneighborlists::Vector{Vector{Vector{Int}}}: A vector over time steps. For each time step, a vector over particles, where neighborlists[t][i] contains the list of neighbors of particle i.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bond-Breaking-Parameter","page":"API","title":"Bond Breaking Parameter","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_CB","page":"API","title":"SimulationAnalysis.find_CB","text":"find_CB(s::Simulation, neighbourlists1::Vector{<:Vector}, neighbourlists2::Vector{<:Vector})\n\nCalculates the bond-breaking correlation function C_B(t) for all particles.\n\nThis function measures the fraction of neighbors that a particle at time t_0 still has at a later time t_0 + t. It is averaged over all particles and time origins t_0.\n\nArguments\n\ns::Simulation: The simulation data, used for time information.\nneighbourlists1::Vector{<:Vector}: A vector of neighbor lists at the initial times (t_0).\nneighbourlists2::Vector{<:Vector}: A vector of neighbor lists at the final times (t_0 + t). Often, this is the same as neighbourlists1.\n\nReturns\n\nCB::Matrix{Float64}: A (Ndt, N) matrix where CB[i, j] is the bond-breaking correlation for particle j at time delay dt_array[i].\n\n\n\n\n\n","category":"function"},{"location":"api/#Utils","page":"API","title":"Utils","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_relaxation_time","page":"API","title":"SimulationAnalysis.find_relaxation_time","text":"find_relaxation_time(t::AbstractVector, F::AbstractVector; threshold::Float64=exp(-1))\n\nCalculates the relaxation time τ of a decaying function F(t).\n\nThe relaxation time is defined as the time at which F(t) first drops below a certain threshold. The function finds this time by performing linear interpolation between the two points straddling the threshold. The interpolation is linear in F and log(t).\n\nArguments\n\nt::AbstractVector: A vector of time points.\nF::AbstractVector: A vector of the function values F(t), corresponding to the time points in t. This function should be monotonically decreasing.\nthreshold::Float64=exp(-1): The threshold value for F(t). The relaxation time is t such that F(t) = threshold.\n\nReturns\n\nτ::Float64: The calculated relaxation time. Returns 0.0 if the function is already below the threshold at the first time point. Returns Inf if the function never drops below the threshold.\n\n\n\n\n\n","category":"function"},{"location":"api/#Radial-Distribution-Function","page":"API","title":"Radial Distribution Function","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_radial_distribution_function","page":"API","title":"SimulationAnalysis.find_radial_distribution_function","text":"find_radial_distribution_function(s::MultiComponentSimulation, Nbins::Int, rmax::Float64)\n\nCalculates the partial radial distribution functions g_αβ(r) for a multi-component simulation.\n\nThe g_αβ(r) describes the probability of finding a particle of species β at a distance r from a particle of species α, relative to that of an ideal gas.\n\nArguments\n\ns::MultiComponentSimulation: The simulation data.\nNbins::Int: The number of bins to use for the histogram.\nrmax::Float64: The maximum distance to consider. If negative, it's set to half the smallest box dimension.\n\nReturns\n\nbin_centres::Vector{Float64}: A vector of the centre points of the histogram bins.\ng_r::Matrix{Vector{Float64}}: A matrix of vectors, where g_r[α, β] is the partial g_αβ(r).\n\n\n\n\n\nfind_radial_distribution_function(s::SingleComponentSimulation, Nbins::Int, rmax::Float64; Ntasks::Int=1)\n\nCalculates the radial distribution function g(r) for a single-component simulation.\n\nThe g(r) describes the probability of finding a particle at a distance r from another particle, relative to that of an ideal gas.\n\nArguments\n\ns::SingleComponentSimulation: The simulation data.\nNbins::Int: The number of bins to use for the histogram.\nrmax::Float64: The maximum distance to consider. If negative, it's set to half the smallest box dimension.\nNtasks::Int=1: The number of parallel tasks to use for the calculation.\n\nReturns\n\nbin_centres::Vector{Float64}: A vector of the centre points of the histogram bins.\ng_r::Vector{Float64}: A vector containing the values of g(r).\n\n\n\n\n\nfind_radial_distribution_function(s::SingleComponentSimulation, dr::Float64, rmax::Float64; Ntasks::Int=1)\n\nCalculates the radial distribution function g(r) for a single-component simulation.\n\nThis method defines the histogram bins by a fixed width dr.\n\nArguments\n\ns::SingleComponentSimulation: The simulation data.\ndr::Float64: The width of the histogram bins.\nrmax::Float64: The maximum distance to consider. If negative, it's set to half the smallest box dimension.\nNtasks::Int=1: The number of parallel tasks to use for the calculation.\n\nReturns\n\nbin_centres::Vector{Float64}: A vector of the centre points of the histogram bins.\ng_r::Vector{Float64}: A vector containing the values of g(r).\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This page provides examples for various analysis functions available in SimulationAnalysis.jl.","category":"page"},{"location":"examples/#Common-Setup","page":"Examples","title":"Common Setup","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"All examples on this page use a sample trajectory file included with the package. The following code loads the simulation data and will be used as a common starting point for the examples below. We also assume that you have Plots.jl installed and loaded for the plotting examples.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SimulationAnalysis\nusing Plots\n\n# Construct the path to the test trajectory file\nfilepath = joinpath(dirname(pathof(SimulationAnalysis)), \"..\", \"test\", \"data\", \"test_trajectory.h5\")\n\n# Load the simulation into a SingleComponentSimulation object\n# If you have access to the data in some other format, you need to \n# construct a Simulation object manually.\nsim = SimulationAnalysis.read_continuously_hard_sphere_simulation(filepath; time_origins=10)\ndt = sim.t_array[2] - sim.t_array[1]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/#Radial-Distribution-Function-(g(r))","page":"Examples","title":"Radial Distribution Function (g(r))","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The radial distribution function describes the structure of the system.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Set parameters for g(r) calculation\nNbins = 100\nrmax = 5.0\n\n# Calculate the radial distribution function\nbin_centres, g_r = SimulationAnalysis.find_radial_distribution_function(sim, Nbins, rmax)\n\n# Plot the g(r)\nplot(bin_centres, g_r,\n    xlabel=\"r (particle diameters)\",\n    ylabel=\"g(r)\",\n    title=\"Radial Distribution Function\",\n    legend=false,\n    lw=2\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: gr)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/#K-Space-Analysis","page":"Examples","title":"K-Space Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"These functions are used for analyzing the structure and dynamics in reciprocal space.","category":"page"},{"location":"examples/#Constructing-K-Space","page":"Examples","title":"Constructing K-Space","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, we need to construct the k-space vectors.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Construct the k-space vectors\nkspace = SimulationAnalysis.construct_k_space(sim, (0.0, 10.0); kfactor=1)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is a SimulationAnalysis.KSpace{3, SimulationAnalysis.SingleComponentSimulation, OffsetArrays.OffsetArray{Int64, 3, Array{Int64, 3}}}.\nIt contains \ns: SimulationAnalysis.SingleComponentSimulation\nNk: 2418\nk_lengths: Vector{Float64}\nk_array: Matrix{Float64}\nkfactor: 1\ncartesian_to_linear: OffsetArrays.OffsetArray{Int64, 3, Array{Int64, 3}}","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can compute the corresponding density modes:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"density_modes = SimulationAnalysis.find_density_modes(sim, kspace; verbose=false)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"SingleComponentDensityModes with real and imaginary parts of size (430, 2418).","category":"page"},{"location":"examples/#Structure-Factor-(S(k))","page":"Examples","title":"Structure Factor (S(k))","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The structure factor is the Fourier transform of the radial distribution function and describes the static correlations in the system.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Calculate the structure factor for a specific k-range\nS_k = SimulationAnalysis.find_structure_factor(sim; kmin=2.0, kmax=2.4)\n\nprintln(\"Structure factor calculated: \", S_k)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Structure factor calculated: 0.12698982578981327","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If the goal is to compute S(k) at many different points in k, it is more efficient to use the precomputed density modes from above","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Calculate the structure factor for a specific k-range\nk_sample_arr = 2:0.3:10\nS_k = SimulationAnalysis.find_structure_factor(sim, kspace, density_modes, k_sample_arr; k_binwidth=0.1)\nplot(k_sample_arr, S_k,\n    xlabel=\"k \",\n    ylabel=\"S(k)\",\n    title=\"Static Structure Factor\",\n    legend=false,\n    lw=2\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Sk)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The gap in the figure is caused by the absence of any wave vectors that have the length corresponding to that bin. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/#Intermediate-Scattering-Function-(ISF)","page":"Examples","title":"Intermediate Scattering Function (ISF)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The intermediate scattering function, F(k, t), measures the decay of density correlations at a specific wave vector k over time t.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Calculate the intermediate scattering function for a specific k-range\nisf = SimulationAnalysis.find_intermediate_scattering_function(sim; kmin=7.0, kmax=7.4)\n\n# Plot the ISF\nplot(dt * sim.dt_array[2:end], isf[2:end],\n    xlabel=\"Time t\",\n    ylabel=\"F(k, t)\",\n    title=\"Intermediate Scattering Function\",\n    legend=false,\n    lw=2,\n    xaxis=:log\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Fkt)","category":"page"},{"location":"examples/#Self-Intermediate-Scattering-Function-(Self-ISF)","page":"Examples","title":"Self-Intermediate Scattering Function (Self-ISF)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The self-intermediate scattering function, F_s(k, t), is the single-particle equivalent of the ISF. It measures the correlation of a single particle's position over time.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Calculate the self-intermediate scattering function\nself_isf, self_isf_per_particle = SimulationAnalysis.find_self_intermediate_scattering_function(sim, kspace; kmin=7.0, kmax=7.4)\n\n# Plot the Self-ISF\nplot(dt * sim.dt_array[2:end], self_isf[2:end],\n    xlabel=\"Time\",\n    ylabel=\"F_s(k, t)\",\n    title=\"Self-Intermediate Scattering Function\",\n    legend=false,\n    lw=2,\n    xaxis=:log\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Fskt)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/#Neighbor-Lists","page":"Examples","title":"Neighbor Lists","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Neighbor lists are used to efficiently find particles that are close to each other. These functions return lists of neighbors and are not typically plotted directly.","category":"page"},{"location":"examples/#Absolute-Distance-Neighbor-List","page":"Examples","title":"Absolute Distance Neighbor List","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This method finds all particles within a certain absolute distance of each other.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Find neighbor lists based on a cutoff distance\nneighborlists_abs = SimulationAnalysis.find_absolute_distance_neighborlists(sim, 2.0)\n\nprintln(\"Absolute distance neighbor lists calculated for \", length(neighborlists_abs), \" time steps.\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Absolute distance neighbor lists calculated for 430 time steps.","category":"page"},{"location":"examples/#Voronoi-Neighbor-List","page":"Examples","title":"Voronoi Neighbor List","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This method uses Voronoi tessellation to determine neighbors. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"THIS IS CURRENTLY BROKEN ON JULIA 1.11 (QUICKHULL.jl segfaults)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Find neighbor lists using Voronoi tessellation\nneighborlists_voronoi = SimulationAnalysis.find_voronoi_neighborlists(sim)\n\nprintln(\"Voronoi neighbor lists calculated for \", length(neighborlists_voronoi), \" time steps.\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Voronoi neighbor lists calculated for 430 time steps.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/#Bond-Correlation-Function-(Cb)","page":"Examples","title":"Bond Correlation Function (Cb)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The bond correlation function is used to study the dynamics of local structure. It requires neighbor lists as input.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# First, calculate neighbor lists (e.g., Voronoi)\nneighborlists = SimulationAnalysis.find_absolute_distance_neighborlists(sim, 2.0)\n\n# Calculate the bond correlation function for each particle\nCb_per_particle = SimulationAnalysis.find_CB(sim, neighborlists, neighborlists)\n# average over particles\nCb = sum(Cb_per_particle, dims=2)[:] / size(Cb_per_particle, 2)\n\n# Plot the bond correlation function for a single particle\nplot(dt*sim.dt_array[2:end], Cb[2:end],\n    xlabel=\"Time\",\n    ylabel=\"Cb(t)\",\n    title=\"Bond Correlation Function (Particle 1)\",\n    legend=false,\n    lw=2,\n    xscale=:log10\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Cb)","category":"page"},{"location":"examples/#Mean-Squared-Displacement-(MSD)","page":"Examples","title":"Mean Squared Displacement (MSD)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The mean squared displacement is a measure of the average distance a particle travels over time. By default, the particles are stored as mapped into the main box. Therefore we need to construct the date with the original trajectories.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Calculate the mean squared displacement\nsim_original = SimulationAnalysis.read_continuously_hard_sphere_simulation(filepath; time_origins=10, original=true)\nmsd = SimulationAnalysis.find_mean_squared_displacement(sim_original)\n\n# Plot the MSD\nplot(dt*sim.dt_array[2:end], msd[2:end],\n    xlabel=\"Time\",\n    ylabel=\"MSD\",\n    title=\"Mean Squared Displacement\",\n    legend=false,\n    lw=2,\n    xscale=:log10,\n    yscale=:log10,\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: MSD)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"#SimulationAnalysis.jl","page":"Home","title":"SimulationAnalysis.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimulationAnalysis.jl is a Julia package for analyzing molecular dynamics simulations.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Load simulation data from various formats.\nCalculate various observables, such as:\nRadial distribution function\nMean squared displacement\nIntermediate scattering function\nStructure factor\nand more.","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"API Reference: Detailed information about all public functions and types.\nTutorial: A step-by-step guide to using the package.\nExamples: A collection of examples showcasing different features.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial provides a step-by-step guide to using SimulationAnalysis.jl for analyzing particle-based simulation data. We will cover loading a simulation, calculating the radial distribution function, and visualizing the results.","category":"page"},{"location":"tutorial/#1.-Setting-up-the-Environment","page":"Tutorial","title":"1. Setting up the Environment","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Before we begin, make sure you have SimulationAnalysis.jl and a plotting library like Plots.jl installed in your Julia environment.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg\nPkg.add(\"https://github.com/IlianPihlajamaa/SimulationAnalysis.jl\")\nPkg.add(\"Plots\")","category":"page"},{"location":"tutorial/#2.-Loading-Simulation-Data","page":"Tutorial","title":"2. Loading Simulation Data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SimulationAnalysis.jl supports various simulation formats. In this tutorial, we'll use a sample trajectory file included with the package. We will use the read_continuously_hard_sphere_simulation function to load the data into a SingleComponentSimulation object.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SimulationAnalysis\n\n# The test data is located in the `test/data` directory of the package.\n# We can construct the path to the file like this:\nfilepath = joinpath(dirname(pathof(SimulationAnalysis)), \"..\", \"test\", \"data\", \"test_trajectory.h5\")\n\n# Load the simulation data\n# We specify the number of time origins to use for time correlation functions.\nsim = SimulationAnalysis.read_continuously_hard_sphere_simulation(filepath; time_origins=10)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The sim object now holds all the simulation data, including particle positions, box dimensions, and time steps.","category":"page"},{"location":"tutorial/#3.-Calculating-the-Radial-Distribution-Function-(g(r))","page":"Tutorial","title":"3. Calculating the Radial Distribution Function (g(r))","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The radial distribution function, g(r), is a key quantity that describes the structure of a system. It measures the probability of finding a particle at a distance r from another particle.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's calculate g(r) for our simulation. We need to specify the number of bins and the maximum radius for the calculation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Set the parameters for the g(r) calculation\nNbins = 100\nrmax = 10.0\n\n# Calculate the radial distribution function\nbin_centres, gr = find_radial_distribution_function(sim, Nbins, rmax)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The find_radial_distribution_function function returns two arrays: bin_centres, which contains the center of each radial bin, and gr, which contains the corresponding g(r) values.","category":"page"},{"location":"tutorial/#4.-Visualizing-the-Results","page":"Tutorial","title":"4. Visualizing the Results","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A plot is often the best way to interpret the g(r). Let's use Plots.jl to visualize the result.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\n\n# Create a plot of the radial distribution function\nplot(bin_centres, gr,\n    xlabel=\"r (particle diameters)\",\n    ylabel=\"g(r)\",\n    title=\"Radial Distribution Function\",\n    legend=false,\n    lw=2\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: gr)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This will generate a plot showing the characteristic peaks of the g(r) for a liquid-like structure. The first peak corresponds to the nearest neighbors, the second to the next-nearest neighbors, and so on.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial has demonstrated a basic workflow for analyzing simulation data with SimulationAnalysis.jl. You can explore the Examples page for more advanced analysis techniques.","category":"page"}]
}
