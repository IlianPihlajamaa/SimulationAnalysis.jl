var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/#Simulation","page":"API","title":"Simulation","text":"","category":"section"},{"location":"api/#SimulationAnalysis.SingleComponentSimulation","page":"API","title":"SimulationAnalysis.SingleComponentSimulation","text":"SingleComponentSimulation\n\nA mutable struct that holds all data for a single-component particle simulation.\n\nFields\n\nN::Int64: Number of particles.\nNdims::Int64: Number of spatial dimensions.\nr_array::Array{Float64, 3}: Particle positions. The dimensions of the array are (N, Ndims, N_time_steps).\nv_array::Array{Float64, 3}: Particle velocities. The dimensions of the array are (N, Ndims, N_time_steps).\nF_array::Array{Float64, 3}: Forces on particles. The dimensions of the array are (N, Ndims, N_time_steps).\nD_array::Array{Float64, 1}: Diffusion coefficient for each particle.\nt_array::Array{Float64, 1}: Vector of time points corresponding to each time step.\nbox_sizes::Vector{Float64}: A vector holding the simulation box dimensions, e.g., [Lx, Ly, Lz].\ndt_array::Array{Int64, 1}: An array of time step differences (Δt) used for calculating time correlation functions.\nt1_t2_pair_array::Vector{Array{Int64, 2}}: An array of (t1, t2) index pairs, used for efficient calculation of time correlations.\nfilepath::String: Path to the file from which the simulation data was loaded.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationAnalysis.MultiComponentSimulation","page":"API","title":"SimulationAnalysis.MultiComponentSimulation","text":"MultiComponentSimulation\n\nA mutable struct that holds all data for a multi-component particle simulation.\n\nFields\n\nN::Int64: Total number of particles across all species.\nNdims::Int64: Number of spatial dimensions.\nN_species::Int64: Number of different particle species.\nN_particles_per_species::Vector{Int}: A vector containing the number of particles for each species.\nr_array::Vector{Array{Float64, 3}}: A vector of particle position arrays. Each element r_array[i] is a (N_particles_per_species[i], Ndims, N_time_steps) array for species i.\nv_array::Vector{Array{Float64, 3}}: A vector of particle velocity arrays for each species.\nF_array::Vector{Array{Float64, 3}}: A vector of particle force arrays for each species.\nt_array::Vector{Float64}: Vector of time points corresponding to each time step.\nbox_sizes::Vector{Float64}: A vector holding the simulation box dimensions, e.g., [Lx, Ly, Lz].\ndt_array::Vector{Int}: An array of time step differences (Δt) used for calculating time correlation functions.\nt1_t2_pair_array::Vector{Array{Int64, 2}}: An array of (t1, t2) index pairs, used for efficient calculation of time correlations.\nfilepath::String: Path to the file from which the simulation data was loaded.\n\n\n\n\n\n","category":"type"},{"location":"api/#K-Space","page":"API","title":"K-Space","text":"","category":"section"},{"location":"api/#SimulationAnalysis.KSpace","page":"API","title":"SimulationAnalysis.KSpace","text":"KSpace{dims, S, OA}\n\nA struct to hold the reciprocal space (k-space) vectors for a simulation.\n\nThis struct is usually created via construct_k_space.\n\nFields\n\ns::S: The Simulation object for which the k-space is defined.\nNk::Int64: The total number of k-vectors.\nk_lengths::Vector{Float64}: A vector of length Nk containing the magnitude of each k-vector.\nk_array::Matrix{Float64}: A (dims, Nk) matrix where each column is a k-vector (kx, ky, kz, ...).\nkfactor::Int64: An integer scaling factor used to determine the resolution of the k-space grid. A higher factor means a courser grid.\ncartesian_to_linear::OA: An OffsetArray that maps the Cartesian grid indices (ix, iy, iz, ...) of a k-vector to its linear index in k_lengths and k_array.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationAnalysis.construct_k_space","page":"API","title":"SimulationAnalysis.construct_k_space","text":"construct_k_space(s::Simulation, bounds; kfactor=1, negative=false, rectangular=false)\n\nConstructs the k-space for a given simulation.\n\nThis function generates a set of k-vectors based on the simulation box and specified parameters. The k-vectors are chosen from a grid with spacing 2π/L * kfactor, where L is the box size in each dimension.\n\nArguments\n\ns::Simulation: The simulation object (SingleComponentSimulation or MultiComponentSimulation).\nbounds: A tuple or vector (kmin, kmax) specifying the range of magnitudes for the k-vectors. k-vectors with magnitude k such that kmin < k < kmax are included.\n\nKeyword Arguments\n\nkfactor::Int=1: An integer scaling factor for the k-vector grid resolution.\nnegative::Bool=false: If true, includes k-vectors with negative components for the first d-1 dimensions.\nrectangular::Bool=false: If true, a rectangular k-space grid is generated, and all k-vectors within the grid up to kmax are included, ignoring kmin. If false, k-vectors are selected from a spherical shell.\n\nReturns\n\nA KSpace object containing the generated k-vectors and related information.\n\nSee also: KSpace\n\n\n\n\n\n","category":"function"},{"location":"api/#Correlation-Function","page":"API","title":"Correlation Function","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_correlation_function","page":"API","title":"SimulationAnalysis.find_correlation_function","text":"find_correlation_function(A, B, s)\n\nComputes the correlation function between two lists of observables. The observables are assumed to be complex-valued. The correlation function is a complex number. The correlation function is averaged over the first dimension of A and B.\n\nArguments\n\nA::Array{Complex{Float64}, 2}: The first list of observables.\nB::Array{Complex{Float64}, 2}: The second list of observables.\ns::Simulation: The simulation.\n\nReturns\n\nC::Array{Complex{Float64}, 1}: The correlation function.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationAnalysis.find_correlation_matrix","page":"API","title":"SimulationAnalysis.find_correlation_matrix","text":"find_correlation_matrix(observables_list1, observables_list2, kspace, s)\n\nComputes the correlation matrix between two lists of observables. The observables are assumed to be complex-valued. The correlation matrix is a matrix of complex numbers.\n\nArguments\n\nobservables_list1::Array{Array{Complex{Float64}, 2}, 1}: The first list of observables.\nobservables_list2::Array{Array{Complex{Float64}, 2}, 1}: The second list of observables.\ns::Simulation: The simulation.\n\nReturns\n\nmatrix::Array{Array{Complex{Float64}, 1}, 2}: The correlation matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#Density-Modes","page":"API","title":"Density Modes","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_density_modes","page":"API","title":"SimulationAnalysis.find_density_modes","text":"find_density_modes(s::SingleComponentSimulation, kspace::KSpace; verbose=true)\n\nCalculates the density modes ρ(k,t) = Σ_j exp(i * k ⋅ r_j(t)) for a single-component simulation.\n\nThe calculation is performed for all k-vectors in kspace and for all time steps in the simulation. This function is computationally intensive. The verbose option can be used to monitor progress.\n\nArguments\n\ns::SingleComponentSimulation: The simulation data.\nkspace::KSpace: The k-space vectors for which to calculate the density modes.\nverbose::Bool=true: If true, prints progress and performance information to the console.\n\nReturns\n\nSingleComponentDensityModes: A struct containing the real and imaginary parts of the density modes.\n\nSee also: SingleComponentDensityModes, find_density_modes(::MultiComponentSimulation, ::KSpace)\n\n\n\n\n\nfind_density_modes(s::MultiComponentSimulation, kspace::KSpace; verbose=true)\n\nCalculates the density modes ρ_s(k,t) = Σ_j exp(i * k ⋅ r_j(t)) for each species s in a multi-component simulation.\n\nThe calculation is performed for all k-vectors in kspace and for all time steps in the simulation. This function is computationally intensive. The verbose option can be used to monitor progress.\n\nArguments\n\ns::MultiComponentSimulation: The simulation data.\nkspace::KSpace: The k-space vectors for which to calculate the density modes.\nverbose::Bool=true: If true, prints progress and performance information to the console.\n\nReturns\n\nMultiComponentDensityModes: A struct containing the real and imaginary parts of the density modes for each species.\n\nSee also: MultiComponentDensityModes, find_density_modes(::SingleComponentSimulation, ::KSpace)\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationAnalysis.SingleComponentDensityModes","page":"API","title":"SimulationAnalysis.SingleComponentDensityModes","text":"SingleComponentDensityModes\n\nA struct to hold the density modes ρ(k,t) for a single-component simulation.\n\nThe density modes are defined as ρ(k,t) = Σ_j exp(i * k ⋅ r_j(t)), where the sum is over all particles j. This struct stores the real and imaginary parts of ρ(k,t) for various k-vectors and time steps.\n\nFields\n\nRe::Matrix{Float64}: The real part of the density modes, Σ_j cos(k ⋅ rj). Dimensions are (N_timesteps, Nk).\nIm::Matrix{Float64}: The imaginary part of the density modes, Σ_j sin(k ⋅ rj). Dimensions are (N_timesteps, Nk).\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationAnalysis.MultiComponentDensityModes","page":"API","title":"SimulationAnalysis.MultiComponentDensityModes","text":"MultiComponentDensityModes\n\nA struct to hold the density modes ρ_s(k,t) for each species s in a multi-component simulation.\n\nThe density modes for each species are defined as ρ_s(k,t) = Σ_j exp(i * k ⋅ r_j(t)), where the sum is over all particles j of species s. This struct stores the real and imaginary parts of ρ_s(k,t) for various k-vectors and time steps.\n\nFields\n\nRe::Vector{Matrix{Float64}}: A vector where Re[s] is the real part of the density modes for species s. Each matrix has dimensions (N_timesteps, Nk).\nIm::Vector{Matrix{Float64}}: A vector where Im[s] is the imaginary part of the density modes for species s. Each matrix has dimensions (N_timesteps, Nk).\n\n\n\n\n\n","category":"type"},{"location":"api/#Forces","page":"API","title":"Forces","text":"","category":"section"},{"location":"api/#SimulationAnalysis.Weysser","page":"API","title":"SimulationAnalysis.Weysser","text":"Weysser <: InteractionPotential\n\nA struct for the Weysser interaction potential.\n\nFields\n\nϵ::Float64: The interaction strength.\nδ::Float64: The interaction range.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationAnalysis.Berthier","page":"API","title":"SimulationAnalysis.Berthier","text":"Berthier <: InteractionPotential\n\nA struct for the Berthier interaction potential.\n\nFields\n\nc0::Float64: The c0 coefficient.\nc2::Float64: The c2 coefficient.\nc4::Float64: The c4 coefficient.\nζ::Float64: The zeta coefficient.\nσ_ratio::Float64: The ratio of the diameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationAnalysis.WCA","page":"API","title":"SimulationAnalysis.WCA","text":"WCA <: InteractionPotential\n\nA struct for the WCA interaction potential.\n\nFields\n\nϵ::Float64: The interaction strength.\nσ::Float64: The interaction range.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationAnalysis.KAWCA","page":"API","title":"SimulationAnalysis.KAWCA","text":"KAWCA <: InteractionPotential\n\nA struct for the Kob-Andersen WCA interaction potential.\n\nFields\n\nϵ11::Float64: The interaction strength between particles of type 1.\nϵ12::Float64: The interaction strength between particles of type 1 and 2.\nϵ22::Float64: The interaction strength between particles of type 2.\nσ11::Float64: The interaction range between particles of type 1.\nσ12::Float64: The interaction range between particles of type 1 and 2.\nσ22::Float64: The interaction range between particles of type 2.\n\n\n\n\n\n","category":"type"},{"location":"api/#SimulationAnalysis.calculate_forces!","page":"API","title":"SimulationAnalysis.calculate_forces!","text":"calculate_forces!(s, forcestype::Bool)\n\nCalculate the forces for a simulation.\n\nThis is a placeholder function that throws an error if forcestype is true.\n\nArguments\n\ns: The simulation object.\nforcestype::Bool: Whether to calculate forces.\n\n\n\n\n\ncalculate_forces!(s, U; friction=false, cutoff=1.25)\n\nRecalculates the total force on all particles according to the langevin equation F = -∇U - γv. This function also updates the total potential energy in the output datastructure.\n\n\n\n\n\ncalculate_forces!(s, U::KAWCA; cutoff=2.0^(1.0/6.0))\n\nRecalculates the total force on all particles in a multi-component simulation s according to the Kob-Andersen Weeks-Chandler-Andersen system U, and updates the force array in s with the calculated values.\n\nArguments\n\ns: a MultiComponentSimulation object that contains the position and force arrays for each particle.\nU::KAWCA: the interaction type.\ncutoff: the cutoff distance for the potential energy function. Default is 2.0^(1.0/6.0).\n\n\n\n\n\n","category":"function"},{"location":"api/#Intermediate-Scattering-Function","page":"API","title":"Intermediate Scattering Function","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_intermediate_scattering_function","page":"API","title":"SimulationAnalysis.find_intermediate_scattering_function","text":"find_intermediate_scattering_function(s::Simulation; kmin=7.0, kmax=7.4, kfactor=1)\n\nCalculates the coherent intermediate scattering function F(k, t) for a simulation, averaged over a shell in k-space.\n\nThis is a convenience function that first constructs the k-space and density modes, and then computes F(k, t). The function is defined as: F(k, t) = (1/N) * < Σ_{i,j} exp(i * k ⋅ (r_i(t) - r_j(0))) >. The average is taken over time origins and over k-vectors with magnitudes k such that kmin < k < kmax.\n\nArguments\n\ns::Simulation: The simulation data.\nkmin::Float64=7.0: The minimum magnitude of the k-vectors to be included in the average.\nkmax::Float64=7.4: The maximum magnitude of the k-vectors to be included in the average.\nkfactor::Int=1: The resolution factor for the k-space grid.\n\nReturns\n\nFk: The intermediate scattering function. For a SingleComponentSimulation, this is a Vector{Float64}. For a MultiComponentSimulation, this is a Matrix{Vector{Float64}}.\n\n\n\n\n\nfind_intermediate_scattering_function(s::Simulation, kspace::KSpace, ρkt, k_sample_array::AbstractVector; k_binwidth=0.1)\n\nCalculates the coherent intermediate scattering function F(k, t) for a list of specified k values.\n\nFor each k in k_sample_array, this function computes F(k, t) by averaging over a k-shell of width k_binwidth centered at k.\n\nArguments\n\ns::Simulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nρkt: The pre-computed density modes (SingleComponentDensityModes or MultiComponentDensityModes).\nk_sample_array::AbstractVector: A vector of k-magnitudes for which to compute F(k, t).\nk_binwidth::Float64=0.1: The width of the k-shell to average over for each value in k_sample_array.\n\nReturns\n\nF_array::Vector: A vector where F_array[i] is the F(k,t) corresponding to k_sample_array[i].\n\n\n\n\n\nfind_intermediate_scattering_function(s::SingleComponentSimulation, kspace::KSpace, ρkt::SingleComponentDensityModes; kmin=0.0, kmax=10.0^10.0)\n\nCalculates the coherent intermediate scattering function F(k, t) for a single-component simulation.\n\nThis is the main implementation that computes F(k, t) = (1/N) * <ρ(k, t) ρ*(-k, 0)> by correlating the pre-computed density modes ρkt. The average is performed over time origins and k-vectors within the magnitude range [kmin, kmax].\n\nArguments\n\ns::SingleComponentSimulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nρkt::SingleComponentDensityModes: The pre-computed density modes.\nkmin::Float64=0.0: The minimum magnitude of k-vectors to include in the average.\nkmax::Float64=10.0^10.0: The maximum magnitude of k-vectors to include in the average.\n\nReturns\n\nFk::Vector{Float64}: A vector containing F(k, t) for each time delay Δt in s.dt_array.\n\n\n\n\n\nfind_intermediate_scattering_function(s::MultiComponentSimulation, kspace::KSpace, ρkt::MultiComponentDensityModes; kmin=0.0, kmax=10.0^10.0)\n\nCalculates the partial intermediate scattering functions F_αβ(k, t) for a multi-component simulation.\n\nThis function computes F_αβ(k, t) = (1/N) * <ρ_α(k, t) ρ_β*(-k, 0)> by correlating the pre-computed density modes ρkt for species α and β. The average is performed over time origins and k-vectors within the magnitude range [kmin, kmax].\n\nArguments\n\ns::MultiComponentSimulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nρkt::MultiComponentDensityModes: The pre-computed density modes for all species.\nkmin::Float64=0.0: The minimum magnitude of k-vectors to include in the average.\nkmax::Float64=10.0^10.0: The maximum magnitude of k-vectors to include in the average.\n\nReturns\n\nFk::Matrix{Vector{Float64}}: A matrix of vectors, where Fk[α, β] is the partial intermediate scattering function F_αβ(k, t).\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationAnalysis.find_self_intermediate_scattering_function","page":"API","title":"SimulationAnalysis.find_self_intermediate_scattering_function","text":"find_self_intermediate_scattering_function(s::Simulation; kmin=7.0, kmax=7.4, kfactor=1)\n\nCalculates the self-intermediate scattering function Fs(k, t), averaged over a shell in k-space.\n\nThis is a convenience function that first constructs the k-space and then computes Fs(k, t). The function is defined as: Fs(k, t) = (1/N) * <Σ_j exp(i * k ⋅ (r_j(t) - r_j(0)))>. The average is taken over time origins and over k-vectors with magnitudes k such that kmin < k < kmax. This function is only implemented for SingleComponentSimulation.\n\nArguments\n\ns::Simulation: The simulation data.\nkmin::Float64=7.0: The minimum magnitude of the k-vectors to be included in the average.\nkmax::Float64=7.4: The maximum magnitude of the k-vectors to be included in the average.\nkfactor::Int=1: The resolution factor for the k-space grid.\n\nReturns\n\nFk::Vector{Float64}: A vector containing Fs(k, t) for each time delay Δt in s.dt_array.\nFks_per_particle::Matrix{Float64}: A (Ndt, N) matrix containing the self-intermediate scattering function for each particle.\n\n\n\n\n\nfind_self_intermediate_scattering_function(s::Simulation, kspace::KSpace, k_sample_array::AbstractVector; k_binwidth=0.1)\n\nCalculates the self-intermediate scattering function Fs(k, t) for a list of specified k values.\n\nFor each k in k_sample_array, this function computes Fs(k, t) by averaging over a k-shell of width k_binwidth centered at k. This function is only implemented for SingleComponentSimulation.\n\nArguments\n\ns::Simulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nk_sample_array::AbstractVector: A vector of k-magnitudes for which to compute Fs(k, t).\nk_binwidth::Float64=0.1: The width of the k-shell to average over for each value in k_sample_array.\n\nReturns\n\nF_array::Vector: A vector of tuples (Fk, Fks_per_particle) for each k in k_sample_array.\n\n\n\n\n\nfind_self_intermediate_scattering_function(s::SingleComponentSimulation, kspace::KSpace; kmin=0.0, kmax=10.0^10.0)\n\nCalculates the self-intermediate scattering function Fs(k, t) for a single-component simulation.\n\nThis is the main implementation that computes Fs(k, t) = (1/N) * <Σ_j exp(i * k ⋅ (r_j(t) - r_j(0)))>. The calculation is done without pre-calculating density modes to avoid large memory allocation. The average is performed over time origins and k-vectors within the magnitude range [kmin, kmax].\n\nArguments\n\ns::SingleComponentSimulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nkmin::Float64=0.0: The minimum magnitude of k-vectors to include in the average.\nkmax::Float64=10.0^10.0: The maximum magnitude of k-vectors to include in the average.\n\nReturns\n\nFk::Vector{Float64}: A vector containing Fs(k, t) for each time delay Δt in s.dt_array.\nFks_per_particle::Matrix{Float64}: A (Ndt, N) matrix containing the self-intermediate scattering function for each particle.\n\n\n\n\n\n","category":"function"},{"location":"api/#Structure-Factors","page":"API","title":"Structure Factors","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_structure_factor","page":"API","title":"SimulationAnalysis.find_structure_factor","text":"find_structure_factor(s::Simulation; kmin=7.0, kmax=7.4, kfactor=1)\n\nCalculates the static structure factor S(k) for a simulation, averaged over a shell in k-space.\n\nThis is a convenience function that first constructs the k-space and density modes, and then computes S(k). The function is defined as: S(k) = (1/N) * <|Σ_j exp(i * k ⋅ r_j)|^2>. The average is taken over time and over k-vectors with magnitudes k such that kmin < k < kmax.\n\nArguments\n\ns::Simulation: The simulation data.\nkmin::Float64=7.0: The minimum magnitude of the k-vectors to be included in the average.\nkmax::Float64=7.4: The maximum magnitude of the k-vectors to be included in the average.\nkfactor::Int=1: The resolution factor for the k-space grid.\n\nReturns\n\nSk: The structure factor. For a SingleComponentSimulation, this is a Float64. For a MultiComponentSimulation, this is a Matrix{Float64}.\n\n\n\n\n\nfind_structure_factor(s::Simulation, kspace::KSpace, ρkt::AbstractDensityModes, k_sample_array::AbstractVector; k_binwidth=0.1)\n\nCalculates the static structure factor S(k) for a list of specified k values.\n\nFor each k in k_sample_array, this function computes S(k) by averaging over a k-shell of width k_binwidth centered at k.\n\nArguments\n\ns::Simulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nρkt::AbstractDensityModes: The pre-computed density modes.\nk_sample_array::AbstractVector: A vector of k-magnitudes for which to compute S(k).\nk_binwidth::Float64=0.1: The width of the k-shell to average over for each value in k_sample_array.\n\nReturns\n\nS_array::Vector: A vector where S_array[i] is the S(k) corresponding to k_sample_array[i].\n\n\n\n\n\nfind_structure_factor(s::SingleComponentSimulation, kspace::KSpace, ρkt::SingleComponentDensityModes; kmin=0.0, kmax=10.0^10.0)\n\nCalculates the static structure factor S(k) for a single-component simulation.\n\nThis is the main implementation that computes S(k) = (1/N) * <|ρ(k)|^2> from the pre-computed density modes ρkt. The average is performed over time and k-vectors within the magnitude range [kmin, kmax].\n\nArguments\n\ns::SingleComponentSimulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nρkt::SingleComponentDensityModes: The pre-computed density modes.\nkmin::Float64=0.0: The minimum magnitude of k-vectors to include in the average.\nkmax::Float64=10.0^10.0: The maximum magnitude of k-vectors to include in the average.\n\nReturns\n\nSk::Float64: The value of the structure factor S(k).\n\n\n\n\n\nfind_structure_factor(s::MultiComponentSimulation, kspace::KSpace, ρkt::MultiComponentDensityModes; kmin=0.0, kmax=10.0^10.0)\n\nCalculates the partial static structure factors S_αβ(k) for a multi-component simulation.\n\nThis function computes S_αβ(k) = (1/N) * <ρ_α(k) ρ_β*(-k)> from the pre-computed density modes ρkt for species α and β. The average is performed over time and k-vectors within the magnitude range [kmin, kmax].\n\nArguments\n\ns::MultiComponentSimulation: The simulation data.\nkspace::KSpace: The pre-computed k-space.\nρkt::MultiComponentDensityModes: The pre-computed density modes for all species.\nkmin::Float64=0.0: The minimum magnitude of k-vectors to include in the average.\nkmax::Float64=10.0^10.0: The maximum magnitude of k-vectors to include in the average.\n\nReturns\n\nSk::Matrix{Float64}: A matrix where Sk[α, β] is the partial structure factor S_αβ(k).\n\n\n\n\n\n","category":"function"},{"location":"api/#Mean-Squared-Displacement","page":"API","title":"Mean Squared Displacement","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_mean_squared_displacement","page":"API","title":"SimulationAnalysis.find_mean_squared_displacement","text":"find_mean_squared_displacement(simulation::Simulation; per_particle=false)\n\nCalculates the mean squared displacement (MSD) for a given simulation.\n\nThe MSD is defined as <|r(t) - r(0)|^2>, where the average is taken over all particles and time origins.\n\nArguments\n\nsimulation::Simulation: The simulation data.\nper_particle::Bool=false: If true, the function returns the MSD calculated for each particle individually, in addition to the total MSD.\n\nReturns\n\nIf per_particle is false (default):\n\nmsd::Vector{Float64}: A vector containing the MSD for each time delay Δt in simulation.dt_array.\n\nIf per_particle is true:\n\nmsd::Vector{Float64}: The total MSD vector.\nmsd_per_particle::Matrix{Float64}: A (N, N_dt) matrix of MSDs for each particle.\n\n\n\n\n\nfind_mean_squared_displacement(r, dt_array, t1_t2_pair_array)\n\nCalculates the mean squared displacement (MSD) using pre-calculated time pairs.\n\nThis is the core implementation for calculating the MSD. It iterates through particles and time pairs to compute the displacement.\n\nArguments\n\nr::Array{Float64, 3}: A (Ndims, N, N_timesteps) array of particle positions.\ndt_array::Vector{Int}: An array of time step differences (Δt).\nt1_t2_pair_array::Vector{Array{Int64, 2}}: An array of (t1, t2) index pairs for each Δt.\n\nReturns\n\nmsd::Vector{Float64}: A vector containing the MSD for each time delay Δt in dt_array.\nmsd_per_particle::Matrix{Float64}: A (N, N_dt) matrix of MSDs for each particle.\n\n\n\n\n\n","category":"function"},{"location":"api/#Overlap-Function","page":"API","title":"Overlap Function","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_overlap_function","page":"API","title":"SimulationAnalysis.find_overlap_function","text":"find_overlap_function(s::Simulation; a=0.5)\n\nCalculates the overlap function Q(t).\n\nThe overlap function is a measure of the similarity between the particle configurations at time 0 and time t. It is defined as: Q(t) = (1/N) * Σ_i θ(a - |r_i(t) - r_i(0)|), where θ is the Heaviside step function, a is a cutoff distance, and the average is taken over all particles i and time origins. A value of 1 means the configurations are identical (within the cutoff), and a value of 0 means they are completely different.\n\nArguments\n\ns::Simulation: The simulation data.\na::Float64=0.5: The cutoff distance for calculating the overlap. Typically this is a fraction of the particle diameter.\n\nReturns\n\nFs::Vector{Float64}: A vector containing Q(t) for each time delay Δt in s.dt_array.\nFs_pp::Matrix{Float64}: A (Ndt, N) matrix containing the overlap function for each particle.\n\n\n\n\n\n","category":"function"},{"location":"api/#Neighborlists","page":"API","title":"Neighborlists","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_relative_distance_neighborlists","page":"API","title":"SimulationAnalysis.find_relative_distance_neighborlists","text":"find_relative_distance_neighborlists(s::SingleComponentSimulation, rc::Float64; ζ::Float64 = 0.2)\n\nFinds neighbor lists for all time steps based on a relative distance criterion.\n\nThis method is suitable for polydisperse systems where particle diameters vary. Two particles i and j are considered neighbors if the distance between them is less than a cutoff that depends on their respective diameters D_i and D_j: distance(i, j) < rc * (D_i + D_j)/2 * (1 - ζ * abs(D_i - D_j))\n\nThis function requires the D_array (particle diameters) to be loaded in the Simulation object.\n\nArguments\n\ns::SingleComponentSimulation: The simulation data. Must contain particle diameters.\nrc::Float64: The relative cutoff distance.\nζ::Float64=0.2: A parameter to modulate the cutoff for particles of different sizes.\n\nReturns\n\nneighborlists::Vector{Vector{Vector{Int}}}: A vector over time steps. For each time step, a vector over particles, where neighborlists[t][i] contains the list of neighbors of particle i.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationAnalysis.find_absolute_distance_neighborlists","page":"API","title":"SimulationAnalysis.find_absolute_distance_neighborlists","text":"find_absolute_distance_neighborlists(s::Simulation, rc::Float64)\n\nFinds neighbor lists for all time steps based on a fixed, absolute distance cutoff.\n\nTwo particles i and j are considered neighbors if the distance between them is less than rc. Periodic boundary conditions are taken into account.\n\nArguments\n\ns::Simulation: The simulation data.\nrc::Float64: The absolute cutoff distance.\n\nReturns\n\nneighborlists::Vector{Vector{Vector{Int}}}: A vector over time steps. For each time step, a vector over particles, where neighborlists[t][i] contains the list of neighbors of particle i.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimulationAnalysis.find_voronoi_neighborlists","page":"API","title":"SimulationAnalysis.find_voronoi_neighborlists","text":"find_voronoi_neighborlists(s::Simulation; max_distance_from_boundary=3.0, verbose=true, indices=eachindex(s.t_array))\n\nComputes neighbor lists based on Voronoi tessellation for each time step.\n\nTwo particles are considered neighbors if their Voronoi cells are adjacent (i.e., share a facet). This method uses the Quickhull.jl package to perform the Delaunay triangulation, which is the dual of the Voronoi tessellation.\n\nArguments\n\ns::Simulation: The simulation data.\nmax_distance_from_boundary::Float64=3.0: How far from the central box to consider periodic images for the tessellation. This should be large enough to avoid boundary effects.\nverbose::Bool=true: If true, prints progress information.\nindices=eachindex(s.t_array): The range of time step indices to analyze. Defaults to all time steps.\n\nReturns\n\nneighborlists::Vector{Vector{Vector{Int}}}: A vector over time steps. For each time step, a vector over particles, where neighborlists[t][i] contains the list of neighbors of particle i.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bond-Breaking-Parameter","page":"API","title":"Bond Breaking Parameter","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_CB","page":"API","title":"SimulationAnalysis.find_CB","text":"find_CB(s::Simulation, neighbourlists1::Vector{<:Vector}, neighbourlists2::Vector{<:Vector})\n\nCalculates the bond-breaking correlation function C_B(t) for all particles.\n\nThis function measures the fraction of neighbors that a particle at time t_0 still has at a later time t_0 + t. It is averaged over all particles and time origins t_0.\n\nArguments\n\ns::Simulation: The simulation data, used for time information.\nneighbourlists1::Vector{<:Vector}: A vector of neighbor lists at the initial times (t_0).\nneighbourlists2::Vector{<:Vector}: A vector of neighbor lists at the final times (t_0 + t). Often, this is the same as neighbourlists1.\n\nReturns\n\nCB::Matrix{Float64}: A (Ndt, N) matrix where CB[i, j] is the bond-breaking correlation for particle j at time delay dt_array[i].\n\n\n\n\n\n","category":"function"},{"location":"api/#Utils","page":"API","title":"Utils","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_relaxation_time","page":"API","title":"SimulationAnalysis.find_relaxation_time","text":"find_relaxation_time(t::AbstractVector, F::AbstractVector; threshold::Float64=exp(-1))\n\nCalculates the relaxation time τ of a decaying function F(t).\n\nThe relaxation time is defined as the time at which F(t) first drops below a certain threshold. The function finds this time by performing linear interpolation between the two points straddling the threshold. The interpolation is linear in F and log(t).\n\nArguments\n\nt::AbstractVector: A vector of time points.\nF::AbstractVector: A vector of the function values F(t), corresponding to the time points in t. This function should be monotonically decreasing.\nthreshold::Float64=exp(-1): The threshold value for F(t). The relaxation time is t such that F(t) = threshold.\n\nReturns\n\nτ::Float64: The calculated relaxation time. Returns 0.0 if the function is already below the threshold at the first time point. Returns Inf if the function never drops below the threshold.\n\n\n\n\n\n","category":"function"},{"location":"api/#Radial-Distribution-Function","page":"API","title":"Radial Distribution Function","text":"","category":"section"},{"location":"api/#SimulationAnalysis.find_radial_distribution_function","page":"API","title":"SimulationAnalysis.find_radial_distribution_function","text":"find_radial_distribution_function(s::MultiComponentSimulation, Nbins::Int, rmax::Float64)\n\nCalculates the partial radial distribution functions g_αβ(r) for a multi-component simulation.\n\nThe g_αβ(r) describes the probability of finding a particle of species β at a distance r from a particle of species α, relative to that of an ideal gas.\n\nArguments\n\ns::MultiComponentSimulation: The simulation data.\nNbins::Int: The number of bins to use for the histogram.\nrmax::Float64: The maximum distance to consider. If negative, it's set to half the smallest box dimension.\n\nReturns\n\nbin_centres::Vector{Float64}: A vector of the centre points of the histogram bins.\ng_r::Matrix{Vector{Float64}}: A matrix of vectors, where g_r[α, β] is the partial g_αβ(r).\n\n\n\n\n\nfind_radial_distribution_function(s::SingleComponentSimulation, Nbins::Int, rmax::Float64; Ntasks::Int=1)\n\nCalculates the radial distribution function g(r) for a single-component simulation.\n\nThe g(r) describes the probability of finding a particle at a distance r from another particle, relative to that of an ideal gas.\n\nArguments\n\ns::SingleComponentSimulation: The simulation data.\nNbins::Int: The number of bins to use for the histogram.\nrmax::Float64: The maximum distance to consider. If negative, it's set to half the smallest box dimension.\nNtasks::Int=1: The number of parallel tasks to use for the calculation.\n\nReturns\n\nbin_centres::Vector{Float64}: A vector of the centre points of the histogram bins.\ng_r::Vector{Float64}: A vector containing the values of g(r).\n\n\n\n\n\nfind_radial_distribution_function(s::SingleComponentSimulation, dr::Float64, rmax::Float64; Ntasks::Int=1)\n\nCalculates the radial distribution function g(r) for a single-component simulation.\n\nThis method defines the histogram bins by a fixed width dr.\n\nArguments\n\ns::SingleComponentSimulation: The simulation data.\ndr::Float64: The width of the histogram bins.\nrmax::Float64: The maximum distance to consider. If negative, it's set to half the smallest box dimension.\nNtasks::Int=1: The number of parallel tasks to use for the calculation.\n\nReturns\n\nbin_centres::Vector{Float64}: A vector of the centre points of the histogram bins.\ng_r::Vector{Float64}: A vector containing the values of g(r).\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here are some examples of how to use SimulationAnalysis.jl.","category":"page"},{"location":"examples/#Mean-Squared-Displacement","page":"Examples","title":"Mean Squared Displacement","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to calculate the mean squared displacement (MSD) for a simulation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SimulationAnalysis\n\n# Load a simulation\nfilename = \"path/to/your/simulation.dat\"\ndt = 0.005\nsim = read_WCA_simulation(filename, dt)\n\n# Calculate the MSD\nmsd = find_mean_squared_displacement(sim)\n\n# The `msd` variable now contains the mean squared displacement as a function of time.","category":"page"},{"location":"examples/#Intermediate-Scattering-Function","page":"Examples","title":"Intermediate Scattering Function","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to calculate the intermediate scattering function (ISF) for a simulation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SimulationAnalysis\n\n# Load a simulation\nfilename = \"path/to/your/simulation.dat\"\ndt = 0.005\nsim = read_WCA_simulation(filename, dt)\n\n# Define the k-range for the ISF\nkmin = 7.0\nkmax = 7.4\n\n# Calculate the ISF\nisf = find_intermediate_scattering_function(sim; kmin=kmin, kmax=kmax)\n\n# The `isf` variable now contains the intermediate scattering function as a function of time.","category":"page"},{"location":"#SimulationAnalysis.jl","page":"Home","title":"SimulationAnalysis.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimulationAnalysis.jl is a Julia package for analyzing molecular dynamics simulations.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Load simulation data from various formats.\nCalculate various observables, such as:\nRadial distribution function\nMean squared displacement\nIntermediate scattering function\nStructure factor\nand more.","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"API Reference: Detailed information about all public functions and types.\nTutorial: A step-by-step guide to using the package.\nExamples: A collection of examples showcasing different features.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial shows how to use SimulationAnalysis.jl to load a simulation and calculate the radial distribution function.","category":"page"},{"location":"tutorial/#1.-Load-a-simulation","page":"Tutorial","title":"1. Load a simulation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, we need to load a simulation. The package provides several functions for loading different types of simulations, either generated by LAMMPS or by SimulationCode.jl. In this tutorial, we will use read_WCA_simulation to load a simulation of a Weeks-Chandler-Andersen (WCA) fluid.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SimulationAnalysis\n\n# Path to the simulation file\nfilename = \"path/to/your/simulation.txt\"\n\n# Time step of the simulation\ndt = 0.005\n\n# Load the simulation\nsim = read_WCA_simulation(filename, dt)","category":"page"},{"location":"tutorial/#2.-Calculate-the-radial-distribution-function","page":"Tutorial","title":"2. Calculate the radial distribution function","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now that we have loaded the simulation, we can calculate the radial distribution function, g(r).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Number of bins for the g(r)\nNbins = 100\n\n# Maximum radius for the g(r)\nrmax = 10.0\n\n# Calculate the g(r)\nbin_centres, gr = find_radial_distribution_function(sim, Nbins, rmax)","category":"page"},{"location":"tutorial/#3.-Plot-the-results","page":"Tutorial","title":"3. Plot the results","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, we can plot the results using a plotting package of your choice. For example, using Plots.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\n\nplot(bin_centres, gr, xlabel=\"r\", ylabel=\"g(r)\", legend=false)","category":"page"}]
}
